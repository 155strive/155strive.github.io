<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>git基础命令</title>
      <link href="/2022/12/23/git/"/>
      <url>/2022/12/23/git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-基础入门手册"><a href="#Git-基础入门手册" class="headerlink" title="Git 基础入门手册"></a>Git 基础入门手册</h1><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>版本控制 ( Revision control ) 是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p><ul><li>实现跨区域多人协同开发；</li><li>追踪和记载一个或多个文件的历史记录；</li><li>组织和保护您的源代码和文档；</li><li>统计工作量；</li><li>并行开发、提高开发效率；</li><li>跟踪记录整个软件的开发过程；</li><li>减轻开发人员的负担，节省时间，同时降低认为错误。</li></ul><h4 id="常见的版本控制工具"><a href="#常见的版本控制工具" class="headerlink" title="常见的版本控制工具"></a>常见的版本控制工具</h4><ul><li>Git</li><li>SVN ( Subversion )</li><li>CVS ( Concurrent Versions System )</li><li>VSS ( Microsoft Visual SourceSafe )</li><li>TFS ( Team Foundation Server )</li><li>Visual Studio Online</li></ul><h4 id="版本控制分类"><a href="#版本控制分类" class="headerlink" title="版本控制分类"></a>版本控制分类</h4><p><strong>1、本地版本控制</strong></p><p>记录文件每次的更新，可以对每个版本左一个快照，或是记录补丁文件，适合个人使用。如 RCS。</p><p><strong>2、集中版本控制</strong></p><p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改。如 SVN、CVS、VSS。</p><p><strong>3、分布式版本控制</strong></p><p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时 push 到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这也增加了本地存储空间的占用。如 Git</p><h2 id="Git-基本理论"><a href="#Git-基本理论" class="headerlink" title="Git 基本理论"></a>Git 基本理论</h2><p>Git 本地有三个工作区域 “工作目录 ( Working Directory )”、”暂存区 ( Stage / Index )”、”资源库 ( Repository / Git Directory )”，如果加上远程服务器，则还有 “远程 Git 仓库 ( Remote Directory )”。文件就在这四个区域之间转换。</p><ol><li>工作目录 ( Working Directory )：平时存放项目代码的地方；</li><li>暂存区 ( Stage / Index )：用于临时存放改动过的文件，事实上它只是文件，保存即将提交的文件列表信息；</li><li>资源库 ( Repository / Git Directory )：安全存放数据的位置，这里有提交到所有版本的数据，其中 HEAD 指向最新放入仓库的版本；</li><li>远程 Git 仓库 ( Remote Directory )：托管代码的服务器，可以简单认为是项目组中的一台电脑用于远程数据交换。</li></ol><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li>在工作目录添加、修改文件；</li><li>将需要进行版本管理的文件放入暂存区域；( git add. )</li><li>将暂存区域的文件提交到 git 仓库； ( git commit )</li><li>将本地资源库推送到远程仓库。 ( git push )</li></ol><h2 id="开始使用-码云"><a href="#开始使用-码云" class="headerlink" title="开始使用 (码云)"></a>开始使用 (码云)</h2><h3 id="设置-SSH-公钥"><a href="#设置-SSH-公钥" class="headerlink" title="设置 SSH 公钥"></a>设置 SSH 公钥</h3><p>设置本机 SSH 公钥，实现免密码登录</p><ol><li>使用 ssh-keygen -t rsa 命令在电脑中生成一个公钥；</li><li>找到公钥所在文件夹，将 id_rsa.pub 中的代码复制下来；</li><li>去码云个人设置 – 安全设置 – SSH 公钥中粘贴然后保存;</li><li>验证成功即可使用。</li></ol><p>绑定成功后，即可在自己的账号中新建仓库，获取获取别的仓库。</p><h3 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h3><p>进入目标文件夹中使用克隆命令，将直接从远程仓库中镜像一份到本地目录</p><pre class="line-numbers language-none"><code class="language-none">git clone url<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="文件的-4-种状态"><a href="#文件的-4-种状态" class="headerlink" title="文件的 4 种状态"></a>文件的 4 种状态</h4><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还步想提交的文件，或者要提交的文件没有提交上。</p><ol><li>Untracked: 未跟踪，此文件在文件夹中，但并没有加入到 git 库，不参与版本控制，通过 git add . 状态 变为 Staged ；</li><li>Unmodify: 文件已经入库，但未进行修改，即版本库中的文件快照内容与文件夹中完全一致，这种类型有的文件有两种去处，如果他被修改，而变成 Modified 。如果使用 git rm 移出版本库，则成为 Untracked 文件；</li><li>Modified: 文件已修改，仅仅是修改，并没有进行其他操作。这个文件也有两个去处，通过 git add 可进入暂存 Staged 状态，使用 git checkout 则丢弃修改，返回到 Unmodify 状态，这个 git checkout 即从库中取出文件，覆盖当前修改；</li><li>Staged: 暂存状态，执行 git commit 则将修改同步到库中，这时库中的文件和本地文件又变为一致，文件为 Unmodify 状态。执行 git reset HEAD filename 取消暂存，文件状态为 Modified</li></ol><h2 id="常用-Git-命令"><a href="#常用-Git-命令" class="headerlink" title="常用 Git 命令"></a>常用 Git 命令</h2><h3 id="创建-x2F-克隆仓库"><a href="#创建-x2F-克隆仓库" class="headerlink" title="创建/克隆仓库"></a>创建/克隆仓库</h3><pre class="line-numbers language-none"><code class="language-none">// 在当前目录新建一个Git代码库git init// 新建一个目录，将其初始化为Git代码库git init [project-name]// 克隆远程仓库git clone [url]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><pre class="line-numbers language-none"><code class="language-none">// 显示当前的Git配置git config --list// 编辑Git配置文件git config -e [--global]// 设置提交代码时的用户信息git config [--global] user.name "[name]"git config [--global] user.email "[email address]"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="管理文件-x2F-目录"><a href="#管理文件-x2F-目录" class="headerlink" title="管理文件/目录"></a>管理文件/目录</h3><pre class="line-numbers language-none"><code class="language-none">// 查看指定文件状态git status [file]// 查看所有文件状态git status// 添加指定文件到暂存区git add [file1] [file1] ...// 添加指定目录到暂存区，包括子目录git add [dir]// 添加当前目录的所有文件到暂存区git add .// 删除工作区文件，并将这次删除放入暂存区git rm [file1] [file1] ...// 停止追踪指定文件，但该文件会保留在工作区git rm --cached [file]// 改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><pre class="line-numbers language-none"><code class="language-none">// 提交暂存区文件到资源库git commit -m "备注文字"// 提交暂存区的指定文件到资源库git commit [file1] [file2] ... -m "备注文字"// 提交工作区自上次commit之后的变化，直接到资源库git commit -a// 提交时显示所有diff信息git commit -v// 使用一次新的commit，替代上一次提交// 如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m "备注文字"// 重做上一次commit，并包括指定文件的新变化git commit --amend [file1] [file2] ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><pre class="line-numbers language-none"><code class="language-none">// 恢复暂存区的指定文件到工作区git checkout [file]// 恢复某个commit的指定文件到暂存区和工作区git checkout [commit] [file]// 恢复暂存区的所有文件到工作区git checkout .// 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file]// 重置暂存区与工作区，与上一次commit保持一致git reset --hard// 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit]// 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit]// 重置当前HEAD为指定commit，但保持暂存区和工作区不变git reset --keep [commit]// 新建一个commit，用来撤销指定commit后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit]// 暂时将未提交的变化移除，稍后再移入git stashgit stash pop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><pre class="line-numbers language-none"><code class="language-none">// 提交到远程 Git 仓库git push// 从远程 Git 仓库拉取git pull// 下载远程仓库的所有变动git fetch [remote]// 显示某个远程仓库的信息git remote show [remote]// 增加一个新的远程仓库，并命名git remote add [shortname] [url]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>我们不想把文件目录下的某些文件或目录纳入版本控制中，在主目录下建立 .gitignore 文件，在文件中进行编辑即可。此文件有如下规则：</p><ul><li>忽略文件中的空行或以井号 “#” 开始的行将会被忽略；</li><li>可以使用 Linux 通配符。如：星号 “*” 代表任意多个字符，问号 “?” 代表一个字符，方括号 “[]”代表可选字符范围，花括号 “{}” 代表可选的字符串等；</li><li>如果名称的前面有一个感叹号 “!” ，表示例外规则，将不被忽略；</li><li>如果名称的前面是一个路径分隔符 “/”，表示要忽略的文件在此目录下，而目录中的文件步忽略；</li><li>如果名称的后面是一个路径分隔符 “/”，表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li></ul><pre class="line-numbers language-none"><code class="language-none"># 为注释*.txt  // 忽略所有 .txt 为后缀的文件!lib.txt  // 但lib.txt 除外/temp  // 仅忽略项目根目录下的 TODO 文件，不包括其他目录 tempbuild/  // 忽略 build 目录下的所有文件doc/*.txt  // 忽略 doc/notes.txt 但步包括 doc/server/arch.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常用-Linux-命令"><a href="#常用-Linux-命令" class="headerlink" title="常用 Linux 命令"></a>常用 Linux 命令</h2><pre class="line-numbers language-none"><code class="language-none">cd 目录名(路径) // 改变目录cd .. // 回到上一个目录cd // 直接返回默认目录ls // 获取当前文件夹中所有文件列表touch // 新建一个文件rm 文件名 // 删除一个文件 remove 简写mkdir // 新建一个目录 make dir 简写rm -r 目录名 // 删除一个目录mv 文件名 目录名 // 移动文件 move 简写pwd // 获取当前目录的路径reset // 重新初始化终端clear // 清空之前已经执行的内容history // 查看历史命令help // 帮助exit // 退出# 注释使用 ↑ ↓ 键，可以快速定位到上一次/下一次执行的命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在 mac 系统中，在相应的文件夹下点击 opt + cmd + c 可复制当前文件夹路径</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>javascript基础知识</title>
      <link href="/2022/12/23/javascript-ji-chu-zhi-shi/"/>
      <url>/2022/12/23/javascript-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript-基本语法手册"><a href="#JavaScript-基本语法手册" class="headerlink" title="JavaScript 基本语法手册"></a>JavaScript 基本语法手册</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JavaScript 简称 JS，是运行在客户端的脚本语言，浏览器通过 JavaScript 引擎来执行 JS 代码，JS 引擎执行代码时逐行解释每一句源码然后由计算机去执行，即读取一行就执行一行。</p><p>JavaScript 由三部分组成，ECMAScript ( JavaScript 语法 ), DOM (页面文档对象模型) , BOM ( 浏览器对象模型 )。</p><ul><li><strong>ECMAScript ( JavaScript ):</strong> 规定了 JS 的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套 JS 语法工业标准；</li><li><strong>DOM – 文档对象模型 ( Document Object Model ):</strong> 是 W3C 组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作 (大小、位置、颜色等)；</li><li><strong>BOM – 浏览器对象模型 ( Browser Object Model ):</strong> 它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过 BOM 可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。</li></ul><h2 id="如何引入-JavaScript"><a href="#如何引入-JavaScript" class="headerlink" title="如何引入 JavaScript"></a>如何引入 JavaScript</h2><p>JS 代码可以写在页面的任何位置，有三种不同的写法，为符合标准，建议将所有 JS 都写在外部文件。</p><pre class="line-numbers language-none"><code class="language-none">// 行内插入&lt;input type="button" onclick="alert('a')"&gt;// 页面内嵌&lt;script&gt; ... &lt;/script&gt;// 引入外部文件&lt;script src="filename.js"&gt;&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>所有 JS 代码建议都使用单引号书写；</li><li>引用外部 JS 文件的 <script></script>， 标签内不可写代码。</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><pre class="line-numbers language-none"><code class="language-none">// 单行注释 ， 快捷键 "ctrl + /" 或 "cmd + /"/* 多行注释 * 快捷键 shift + alt + a  * 快捷键是 vscode 中的 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="js的书写规范"><a href="#js的书写规范" class="headerlink" title="js的书写规范"></a>js的书写规范</h2><h3 id="标识符命名规范与语法规范"><a href="#标识符命名规范与语法规范" class="headerlink" title="标识符命名规范与语法规范"></a>标识符命名规范与语法规范</h3><ul><li>变量、函数的名称必须要有意义</li><li>变量名称一般使用名次</li><li>函数名称一般使用动词</li></ul><h3 id="变量的命名规则"><a href="#变量的命名规则" class="headerlink" title="变量的命名规则"></a>变量的命名规则</h3><ul><li>必须以英文字母(包含大小写)、“_” 或 “$” 开头；</li><li>变量名可包含英文字母(包含大小写)、“_” 、 “$” 与数字, 如 usrAge, num01, _name, $age… ；</li><li>严格区分大小写，如 var = app; 和 var = App; 是两个变量；</li><li>不可用系统中有特殊语法含义的关键字或保留字作为变量名 (见下表)；</li><li>命名需有一定的含义，以方便查阅代码可更好的理解；</li><li>遵守驼峰命名法，首字母小写，后面单词的首字母大写，如 myFirstName。</li></ul><p><strong>关键字：</strong></p><p>break case catch continue default delete do else finally for function if in instanceof new return switch this throw try typeof var void while with</p><p><strong>保留字：</strong></p><p>abstract boolean byte char class const debugger double enum export extends final float goto implements import int interface long name native package private protected public short static super synchronized throws transient volatile</p><h3 id="操作符规范"><a href="#操作符规范" class="headerlink" title="操作符规范"></a>操作符规范</h3><ul><li>操作符的左右两侧各保留一个空格</li></ul><h2 id="常用的输入输出语句"><a href="#常用的输入输出语句" class="headerlink" title="常用的输入输出语句"></a>常用的输入输出语句</h2><pre class="line-numbers language-none"><code class="language-none">alert(msg) // 浏览器弹出框console.log(msg) // 浏览器控制台打印输出信息prompt(info) //浏览器弹出输入框，用户可以输入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量即是用于存放数据的容器，我们可以通过变量名获取数据或修改数据，变量的数据存储于内存空间。</p><p>变量的使用包含了两个步骤，1、声明变量。2、给变量赋值，声明一个变量并给他赋值，我们称之为变量的初始化。</p><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><pre class="line-numbers language-none"><code class="language-none">// 变量声明var a;// 变量赋值a = 100;// 简化写法var a = 100;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="更新变量"><a href="#更新变量" class="headerlink" title="更新变量"></a>更新变量</h3><p>一个变量被重新赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准</p><pre class="line-numbers language-none"><code class="language-none">// 变量重新赋值，替换掉之前的值var a = 100;a = 200;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="同时声明多个变量"><a href="#同时声明多个变量" class="headerlink" title="同时声明多个变量"></a>同时声明多个变量</h3><p>只需写一个 var，多个变量之间使用半角逗号 “,” 隔开，结尾使用 “;”结束，为格式标准化，每个变量最好换一行进行声明。</p><pre class="line-numbers language-none"><code class="language-none">// 声明多个变量var a = 100;var b = 200;var c = 300;// 简化写法 ( 单一var模式 )var a = 100,    b = 200,    c = 300;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="声明变量的特殊情况"><a href="#声明变量的特殊情况" class="headerlink" title="声明变量的特殊情况"></a>声明变量的特殊情况</h3><pre class="line-numbers language-none"><code class="language-none">// 只声明不赋值var a;console.log(a); // undefined// 不声明也不赋值console.log(a); // 报错// 不声明直接赋值 (不建议)a = 100;console.log(a); // 100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="let-声明变量-ES6"><a href="#let-声明变量-ES6" class="headerlink" title="let 声明变量 (ES6)"></a>let 声明变量 (ES6)</h3><p>let声明变量的规则与书写格式同 var 大致一致，但有以下几点是和 var 声明变量不同的地方</p><h5 id="let-声明变量不可重复声明"><a href="#let-声明变量不可重复声明" class="headerlink" title="let 声明变量不可重复声明"></a>let 声明变量不可重复声明</h5><pre class="line-numbers language-none"><code class="language-none">let a = 1;let a = b;// 报错，使用 var 声明变量不存在此问题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h5><p>let 声明的变量是块级作用域，作用域块是 ES6 新的概念，只能在代码块中有效，块级作用域简单的说就是花括号里面的作用域，如 {} 或 if / else / while / for 等；</p><pre class="line-numbers language-none"><code class="language-none">{  let a = 1;}console.log(a);// 报错，let声明的变量只在声明的块中起作用。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h5><p>不存在变量提升，在声明之前执行代码会报错</p><pre class="line-numbers language-none"><code class="language-none">console.log(a);let a = 1;// 报错，let声明的变量不会提升<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="不影响作用域链"><a href="#不影响作用域链" class="headerlink" title="不影响作用域链"></a>不影响作用域链</h5><p>这一点和 var 一致</p><pre class="line-numbers language-none"><code class="language-none">{  let a = a;  function fn() {    console.log(a);  }}fn();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="变量的解构赋值-ES6-重学"><a href="#变量的解构赋值-ES6-重学" class="headerlink" title="变量的解构赋值 (ES6) (重学)"></a>变量的解构赋值 (ES6) (重学)</h3><p>Bilibili 视频教程：<a href="https://www.bilibili.com/video/BV1bS4y1b7NV?p=3">https://www.bilibili.com/video/BV1bS4y1b7NV?p=3</a></p><p>ES6 允许按照一定模式从数据或对象中提取值，对变量进行赋值，这被称为解构赋值。</p><pre class="line-numbers language-none"><code class="language-none">// 从数组中提取值const PJ = [3,6,9];let [a,b,c] = PJ; // 声明了三个变量并将数组中的值分别赋给了三个变量// 从变量中提取值const PJ = {  name: 'PUJI',  age: 36,  work: function() {    console.log(name + age + 'years old');  }}let {name, age, work} = PJ; // 声明了三个变量并将对象中的值分别赋给了三个变量// 利用数组结构交换变量的数值let a = 1;let b = 2;[a, b] = [b, a]; // a = 2, b = 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常量-ES6"><a href="#常量-ES6" class="headerlink" title="常量 (ES6)"></a>常量 (ES6)</h2><p>值不可修改的量称为常量。</p><h3 id="常量声明"><a href="#常量声明" class="headerlink" title="常量声明"></a>常量声明</h3><p>使用 const 声明常量，常量名使用全大写字母，用于区分变量</p><pre class="line-numbers language-none"><code class="language-none">const PI = 3.1415926;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="常量的使用规则"><a href="#常量的使用规则" class="headerlink" title="常量的使用规则"></a>常量的使用规则</h3><ul><li>常量声明是必须赋值，并且声明后不可修改；</li><li>一般使用大写作为常量名；</li><li>常量与let声明的变量，也是块级作用域；</li><li>对于数组和对象的元素修改，不算做对常量的修改；</li><li>数组或对象使用常量来声明更为合适。</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>JavaScript 属于弱类型或者说动态语言，这意味着不用提前声明变量的数据类型，在程序运行过程中，类型会被自动确定。</p><p>JavaScript 拥有动态类型，因此变量的数据类型是可以变化的。</p><pre class="line-numbers language-none"><code class="language-none">var a = 6; // a 为数字型var a = 'Puji'; // a 为字符串型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="简单数据类型与复杂数据类型"><a href="#简单数据类型与复杂数据类型" class="headerlink" title="简单数据类型与复杂数据类型"></a>简单数据类型与复杂数据类型</h3><p>目标</p><ul><li>能够说出简单数据类型的内存分配</li><li>能够说出复杂数据类型的内存分配</li><li>能够说出简单类型如何传参</li><li>能够说出复杂类型如何传参</li></ul><p>简单数据类型又叫基本数据类型或者值类型，复杂数据类型又叫引用类型。</p><ul><li>值类型：简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型 String / Number / Boolean / undefined / null (null 返回的是一个空的对象)</li><li>引用类型：复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型，通过 new 关键词创建的对象（自定义对象、内置对象）如 Object / Array / Date 等</li></ul><h5 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h5><ul><li>数字型 Number // 默认值 0</li><li>字符串型 String // 默认值 “”</li><li>布尔型 Boolean // 默认值 false</li><li>未定义 Undefined // 默认值 undefined</li><li>空值 Null // 默认值 null</li><li>Symbol</li></ul><h5 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h5><ul><li>数组 array</li><li>对象 object</li><li>函数 function</li><li>…</li></ul><h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><p>栈：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈</p><p>堆：存储复杂类型，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。</p><p>简单数据类型都放在栈中，复杂数据类型首先在栈里存放地址（十六进制）然后再指向堆里的数据</p><h2 id="简单数据类型-1"><a href="#简单数据类型-1" class="headerlink" title="简单数据类型"></a>简单数据类型</h2><h3 id="数字型-Number"><a href="#数字型-Number" class="headerlink" title="数字型 Number"></a>数字型 Number</h3><p>数字型包含整数或浮点数，0与负数。</p><pre class="line-numbers language-none"><code class="language-none">var num = 10;var PI = 3.14;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>数字型进制通常包括 二进制，八进制，十进制与十六进制,在js中八进制前价0，十六进制前价0x</p><pre class="line-numbers language-none"><code class="language-none">// 1、八进制数字序列范围 （0～7）var num1 = 07;  //对应十进制 7var num2 = 019;  //对应十进制 19var num3 = 08;  //对应十进制 0// 2、十六进制数字序列范围 （0～9以及 a～f）var num = 0xA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="非数字-NaN"><a href="#非数字-NaN" class="headerlink" title="非数字 NaN"></a>非数字 NaN</h5><p>运算结果不是数字时，会返回 NaN，非数字采用 isNaN() 函数进行判断，如果结果是数字，返回的是 false，如果不是数字返回 true</p><pre class="line-numbers language-none"><code class="language-none">var a = 'Hello' - 100; // NaNisNaN(12) // falseisNaN('Puji') // true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符串型-String"><a href="#字符串型-String" class="headerlink" title="字符串型 String"></a>字符串型 String</h3><p>字符串型可以是引号中的任意文本，可以使用单引号或双引号。可以使用单引号与双引号进行嵌套</p><pre class="line-numbers language-none"><code class="language-none">var strMsg1 = 'Puji Design'; // 使用单引号表示字符串var strMsg2 = "Puji Design"; // 使用双引号表示字符串var strMsg3 = Puji Design; // 报错，会被识别为 js代码，但js没有这样的语法var strMsg1 = '"Puji" Design';var strMsg2 = "'Puji' Design";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串不可变"><a href="#字符串不可变" class="headerlink" title="字符串不可变"></a>字符串不可变</h4><p>变量里的字符串值是不可变的，虽然看上去可以改变内容，但其实是地址变了，内存中会心开辟一个内存空间存储新的字符串的值，原来的值还是存在，因此在开发过程中，尽量减少字符串的修改与拼接。</p><pre class="line-numbers language-none"><code class="language-none">// 一直在生成新的内存空间var str = '';for (var i = 1; i&lt;= 100; i++) {  str += i;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h4><h5 id="trim"><a href="#trim" class="headerlink" title="trim()"></a>trim()</h5><p>从一个字符串的两端删除空白字符，不影响原先的字符串本身，将返回一个新的字符串。</p><pre class="line-numbers language-none"><code class="language-none">var str = '   PUJI Design ';var str1 = str.trim();console.log(str1); // PUJI Design<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">// 示例var input = document.querySelector('input');var btn = document.querySelector('button');btn.addEventListener('click', function() {  var inputValue = input.value.trim(); // 如果输入框内输入的空格或文字首尾两端有空格都进行清除  if( inputValue === '') {    alert('请输入内容');  } else {    alert('您的内容已成功提交');  }})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h4><p>类似 html 里的特殊字符，字符串也有特殊字符，也叫做转义符，转义符必须写到引号内，转义符都是用 \ 开头的，常用的转义符如下：</p><pre class="line-numbers language-none"><code class="language-none">\n   换行符，n是newline的意思\\   斜杠 \\'   单引号\"   双引号\t   tab 缩进\b   空格，b是blank的意思<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串类型的拼接"><a href="#字符串类型的拼接" class="headerlink" title="字符串类型的拼接"></a>字符串类型的拼接</h4><p>字符串类型的与其他类型进行相拼接，结果都以字符串类型输出。</p><pre class="line-numbers language-none"><code class="language-none">// 获取字符串的长度str.length;// 字符串的拼接'PUJI' + ' Design'; // PUJI Design'PUJI' + 9; //PUJI9'PUJI' + true; //PUJItrue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="模版字符串-ES6"><a href="#模版字符串-ES6" class="headerlink" title="模版字符串 (ES6)"></a>模版字符串 (ES6)</h4><p>由反引号 “ 包裹的字符串视为模版字符串</p><pre class="line-numbers language-none"><code class="language-none">let str = `PUJI Design`;// 示例1，允许换行let str = `&lt;ul&gt;             &lt;li&gt;Digital&lt;/li&gt;             &lt;li&gt;Branding&lt;/li&gt;             &lt;li&gt;Coding&lt;/li&gt;           &lt;/ul&gt;`;// 示例2，拼接变量let name = 'PUJI';let out = `${name} Design`;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在内容中可以直接出现换行符</li><li>允许使用变量直接在字符串里进行拼接</li></ul><h3 id="布尔型-Boolean"><a href="#布尔型-Boolean" class="headerlink" title="布尔型 Boolean"></a>布尔型 Boolean</h3><p>布尔型包含两个值 true 与 false，布尔型同样可以与数字相加</p><pre class="line-numbers language-none"><code class="language-none">var flag1 = true; // true 1var flag2 = false; // false 0flag1 + 1; // 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="未定义-Undefined"><a href="#未定义-Undefined" class="headerlink" title="未定义 Undefined"></a>未定义 Undefined</h3><p>声明变量但没有赋值的，会有一个默认值 undefined，如果与数字相加，最后的结果是NaN,如果与字符串相连，结果如下：</p><pre class="line-numbers language-none"><code class="language-none">// 以下两种形式都属于 undefinedvar a;var a = undefined;//相加或相连var a;12 + a; // NaN'PUJI' + a; // PUJIundefined<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="空值-Null"><a href="#空值-Null" class="headerlink" title="空值 Null"></a>空值 Null</h3><p>与 undefined 不同，空值如果与数字相加，空值会被视为0，如果与字符串相连，结果如下：</p><pre class="line-numbers language-none"><code class="language-none">var a = null;var a = null;1 + a; // 1'PUJI' + a; // PUJInull<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Symbol-ES6-需重学"><a href="#Symbol-ES6-需重学" class="headerlink" title="Symbol (ES6) (需重学)"></a>Symbol (ES6) (需重学)</h3><p>ES6 引入了一种新的原始值数据类型 Symbol，表示独一无二的值。是一种类似于字符串的数据类型。它的使用场景是给对象添加属性和方法，表示独一无二。</p><h5 id="Symbol特点"><a href="#Symbol特点" class="headerlink" title="Symbol特点"></a>Symbol特点</h5><ul><li>Symbol 的值是唯一的，用来解决命名冲突的问题</li><li>Symbol 的值不能与其他数据类型进行换算</li><li>Symbol 的值不能进行字符串的拼接</li><li>Symbol 定义的对象属性不能使用 for…in 循环遍历，但是可以使用 Reflect.ownKeys 来获取对象的所有键名</li></ul><pre class="line-numbers language-none"><code class="language-none">let s1 = Symbol();let s1 = Symbol('PUJI Design');let s2 = Symbol('PUJI Design');console.log(s1 === s2); // falselet s1 = Symbol.for('PUJI Design');let s2 = Symbol.for('PUJI Design');console.log(s1 === s2); // true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">let a = {  [Symbol('name'): 'PUJI';}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="Symbol-内置值"><a href="#Symbol-内置值" class="headerlink" title="Symbol 内置值"></a>Symbol 内置值</h5><pre class="line-numbers language-none"><code class="language-none">Symbol.hasInstance<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="数据类型的操作"><a href="#数据类型的操作" class="headerlink" title="数据类型的操作"></a>数据类型的操作</h2><h3 id="typeof-获取变量的数据类型"><a href="#typeof-获取变量的数据类型" class="headerlink" title="typeof 获取变量的数据类型"></a>typeof 获取变量的数据类型</h3><pre class="line-numbers language-none"><code class="language-none">var a = 10;typeof a; // numbervar b = 'PUJI';typeof b; // stringvar c = true;typeof c; // booleanvar d;typeof d; // undefinedvar e = null;typeof e; // object<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h3><p>即把一种数据类型转换为另一种数据类型，常用的3种转换方式</p><h5 id="转换为字符串型"><a href="#转换为字符串型" class="headerlink" title="转换为字符串型"></a>转换为字符串型</h5><pre class="line-numbers language-none"><code class="language-none">var num = 1;// 方法1num.toString();// 方法2String(num);// 方法3（隐式转换）num + '';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="转换为数字型"><a href="#转换为数字型" class="headerlink" title="转换为数字型"></a>转换为数字型</h5><pre class="line-numbers language-none"><code class="language-none">// 将 string 类型转换成整数数值型 (如果有小数点，将在小数点前取整)parseInt('9'); // 9// 将 string 类型转换成浮点数值型parseFloat('6.9'); // 6.9// 将 string 类型转换成数值型Number('9'); // 9// 利用算术运算隐式转换为数值型（隐式转换）// 使用的符号包括 "-" "*" "/"'12' - 0; // 12'9' * '3'; // 27<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>parseInt() 与 parseFloat() 的使用方法基本一致，只是一个取整一个取小数的区别</p><pre class="line-numbers language-none"><code class="language-none">parseInt('9');  // 9parseInt('6.9');  // 6parseInt('9px');  // 9parseInt('rem9');  // NaNparseFloat('6.9');  //6.9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="转换为布尔型"><a href="#转换为布尔型" class="headerlink" title="转换为布尔型"></a>转换为布尔型</h5><p>Boolean()函数进行转换，代表空、否定的值都会被转换为 false，如0，NaN，null，undefined。其余都会被转换为 true</p><pre class="line-numbers language-none"><code class="language-none">Boolean(''); // falseBoolean(0); // falseBoolean(NaN); // falseBoolean(null); // falseBoolean(undefined); // falseBoolean('PUJI'); // trueBoolean(9); // true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>运算符 ( Operator ) 也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号。</p><p>JavaScript 中常用的运算符有：</p><ul><li>算数运算符</li><li>递增递减运算符</li><li>比较运算符</li><li>逻辑运算符</li><li>赋值运算符</li></ul><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>用于执行多个变量或值的算数运算，算数运算符的符号包括加”+”、减”-“、乘”*”、除”/”、取模”%”（取余数）。</p><pre class="line-numbers language-none"><code class="language-none">10 + 20; //3010 - 20; //-1010 * 20; // 20010 / 20; //0.59 % 2; //1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>由数字、运算符、变量等以能求得数值的有意义排列方式所得的组合称为表达式。</li><li>表达式最终都会有一个结果返回给我们，这个结果称为返回值。</li><li>在程序中，是将我们右边表达式计算完毕后把返回值给到左边</li><li>浮点数的算数运算里会容易出现问题，尽量避免使用浮点数</li></ul><h3 id="前后置递增-x2F-递减运算符"><a href="#前后置递增-x2F-递减运算符" class="headerlink" title="前后置递增/递减运算符"></a>前后置递增/递减运算符</h3><p>如果需要反复给数字变量添加或减去1，可以使用递增 (++) 或递减 (–) 运算符来完成。在 JavaScript 中，递增 (++) 或递减 (–) 即可以放在变量前面，也可以放在变量后面。放在变量前面时，我们可以称为前置递增（递减）运算符，放在变量后面时，我们称为后置递增（递减）运算符。</p><pre class="line-numbers language-none"><code class="language-none">// 原理var num = 1;num = num + 1;// 简化写法var num = 1;++num<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前置递增/减和后置递增/减如果单独使用，效果是一样的。前置递增先自加1，再与表达式计算返回值，后置递增先返回原值与表达式计算，然后再自加1：</p><pre class="line-numbers language-none"><code class="language-none">// 前置递增和后置递增如果单独使用，效果是一样的var a = 10;++a; // 11var b = 10;b++; // 11// 示例 2var a = 10;++a + 10; // 21var b = 10;b++ + 10; //20 (先使用原值与表达式计算，然后在给变量增加一个+1的值)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">// 前置递增与后置递增的练习var a = 10;++a;var b = ++a + 2; // 14var c = 10;c++;var d = c++ + 2; // 13var e = 10;var f = e++ + ++e; // 22<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>递增/减运算符必须和变量配合使用；</li><li>变量与++/–之间没有空格；</li><li>前置递增/减和后置递增/减运算符单独使用时，运行结果相同，与其他代码联用时结果会不同；</li><li>开发时，大多情况会使用后置递增/减。</li></ul><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>比较运算符也可称为关系运算符，是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值 ( true / false )作为比较运算的结果。</p><p>比较运算符的符号：</p><table><thead><tr><th>符号</th><th>说明</th><th>案例</th><th>结果</th></tr></thead><tbody><tr><td>&lt;</td><td>小于</td><td>3 &lt; 6</td><td>true</td></tr><tr><td>&gt;</td><td>大于</td><td>3 &gt; 6</td><td>false</td></tr><tr><td>&lt;=</td><td>小于等于</td><td>3 &lt;= 3</td><td>true</td></tr><tr><td>&gt;=</td><td>大于等于</td><td>3 &gt;= 6</td><td>false</td></tr><tr><td>==</td><td>判断是否相同 (会转型)</td><td>36 == 36</td><td>true</td></tr><tr><td>!=</td><td>判断是否不相同</td><td>36 != 36</td><td>false</td></tr><tr><td>=== !==</td><td>值和数据类型一起进行对比</td><td>36 === ’36’</td><td>false</td></tr></tbody></table><ul><li>除 “===” 与 “!==” 外，其他的比较运算符都会将字符串型的数据转换为数字型数据</li></ul><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>用来进行布尔值运算的运算符，其返回值也是布尔值。在开发中常用于多个条件的判断。</p><table><thead><tr><th>逻辑运算符</th><th>说明</th><th>案例</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>“逻辑与”，简称”与” and</td><td>true &amp;&amp; false</td></tr><tr><td>||</td><td>“逻辑或”，简称”或” or</td><td>true || false</td></tr><tr><td>!</td><td>“逻辑非”，简称”非” not</td><td>! true</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">// 逻辑与3 &gt; 6 &amp;&amp; 3 &gt; 1; //false，所有结果中，只要有一个是假时则返回 false6 &gt; 3 &amp;&amp; 6 &lt; 9; //true，所有结果都为真时返回 true// 逻辑或3 &gt; 6 || 3 &gt; 1; //true，所有结果中，只要有一个是真时则返回 true6 &lt; 3 || 6 &gt; 9; //false，所有结果都为假时返回 false//逻辑非!(6 &lt; 9); //false//交叉使用!(6 &lt; 9 || 6 == 3); //false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="短路运算（逻辑中断）"><a href="#短路运算（逻辑中断）" class="headerlink" title="短路运算（逻辑中断）"></a>短路运算（逻辑中断）</h3><p>当有多个表达式（值）时，左边的表达式值可以确定结果时，就不再继续运算右边的表达式的值。</p><p>1、逻辑与</p><ul><li>表达式1 &amp;&amp; 表达式2</li><li>如果表达式1的值为真，则返回表达式2</li><li>如果表达式1的值为假，则返回表达式1</li></ul><pre class="line-numbers language-none"><code class="language-none">123 &amp;&amp; 456; // 4560 &amp;&amp; 456; // 0 (所有数字中，除0是假外，其他都是真)0 &amp;&amp; 1 + 2 &amp;&amp; 123 * 456; // 0'' &amp;&amp; 1 + 2 &amp;&amp; 123 * 456; //null &amp;&amp; 0 &amp;&amp; 456; // null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、逻辑或</p><ul><li>表达式1 || 表达式2</li><li>如果表达式1结果为真，则返回的是表达式1</li><li>如果表达式1结果为假，则返回表达式2</li></ul><pre class="line-numbers language-none"><code class="language-none">123 || 456; // 1230 || 456; // 4560 || 1 + 2 || 123 * 456; // 3'' || 1 + 2 || 123 * 456; // 3null || 0 || 456; // 456<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">// 逻辑中断的用法示例var num = 0;123 || num++;console.log(num); // 0 由于使用了逻辑中断，num++并没有进行运算<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table><thead><tr><th>赋值运算符</th><th>说明</th><th>案例</th></tr></thead><tbody><tr><td>=</td><td>直接赋值</td><td>var myName = ‘PUJI’;</td></tr><tr><td>+= , -=</td><td>加 / 减 一个数后再赋值</td><td>var age = 10; age += 5; // 15</td></tr><tr><td>*= , /= , %=</td><td>乘 / 除 / 取模 后再赋值</td><td>var age = 2; age *= 5; // 10</td></tr></tbody></table><h3 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h3><p>bilibili 视频教程: <a href="https://www.bilibili.com/video/BV1bS4y1b7NV?p=4">https://www.bilibili.com/video/BV1bS4y1b7NV?p=4</a></p><p>展开运算符使用 “…” ，能将数组转换为逗号分隔的参数序列，只要可以遍历的元素都可以使用展开运算符。</p><pre class="line-numbers language-none"><code class="language-none">const A = [1,2,3];function pj() {  console.log(arguments);}pj(...A);// 数组的合并const A = [1,2];const B = [3,4];const C = [...A, ...B]// 数组的克隆const A = [1,2];const B = [...A];// 将伪数组转为数组const DIV = document.querySelectorAll('div');const DIVARR = [...DIV];console.log(DIVARR);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>数组的合并可以使用扩展运算符</li><li>数组的克隆</li></ul><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><table><thead><tr><th>优先级</th><th>运算符</th><th>顺序</th></tr></thead><tbody><tr><td>1</td><td>小括号</td><td>()</td></tr><tr><td>2</td><td>一元运算符</td><td>++ — !</td></tr><tr><td>3</td><td>算数运算符</td><td>先* / % 后 + –</td></tr><tr><td>4</td><td>关系运算符</td><td>&gt; &gt;= &lt; &lt;=</td></tr><tr><td>5</td><td>相等运算符</td><td>== != === !==</td></tr><tr><td>6</td><td>逻辑运算符</td><td>先 &amp;&amp; 后 ||</td></tr><tr><td>7</td><td>赋值运算符</td><td>=</td></tr><tr><td>8</td><td>逗号运算符</td><td>,</td></tr></tbody></table><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>在一个程序执行的过程中，各条代码的执行顺序对程序的结果是由直接影响的。很多时候我们要通过控制代码的执行顺序来实现我们想要完成的功能。</p><p>流程控制主要有三种结构，分别是<strong>顺序结构</strong>、<strong>分支结构</strong>和<strong>循环结构</strong>，这三种结构代表三种代码执行的顺序。</p><h2 id="分支流程控制"><a href="#分支流程控制" class="headerlink" title="分支流程控制"></a>分支流程控制</h2><h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><p>由上到下执行代码的过程中，根据不同的条件执行不同的路径代码（执行代码多选一的过程），从而得到不同的结果。</p><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><pre class="line-numbers language-none"><code class="language-none">// 如果if里面的表达式结果为真 (true) 则执行大括号里的代码if (条件表达式) {  ...}//示例if ( 6 &gt; 3 ) {  alert('Yes');}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="if-x2F-else-双分支语句"><a href="#if-x2F-else-双分支语句" class="headerlink" title="if / else 双分支语句"></a>if / else 双分支语句</h3><pre class="line-numbers language-none"><code class="language-none">// 如果if里面的表达式结果为真 (true) 则执行代码1，否则执行代码2if (条件表达式) {  代码 1} else {  代码 2}//示例if ( 6 &gt; 3 ) {  alert('Yes');} else {  alert('No');}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="if-x2F-else-if-多分支语句"><a href="#if-x2F-else-if-多分支语句" class="headerlink" title="if / else if 多分支语句"></a>if / else if 多分支语句</h3><pre class="line-numbers language-none"><code class="language-none">// 如果if里面的表达式结果为真 (true) 则执行代码1，否则执行代码2if (条件表达式1) {  代码 1} else if (条件表达式2) {  代码 2} ... {  ...}else {  代码n}//示例if ( 6 &lt; 3 ) {  alert('Yes');} else if ( 6 &gt; 9 ) {  alert('Yes');} else {  alert('No');}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h3><p>三元表达式也能做一些简单的条件选择，有三元运算符组成的式子称为三元表达式。可以看作是简化版的 if else 语句。三元表达式由符号 “?” 和 “:”组成</p><p>条件表达式 ? 表达式1 : 表达式2<br>如果条件表达式结果为真，则返回表达式1的值，如果条件表达式结果为假，则返回表达式2的值。</p><pre class="line-numbers language-none"><code class="language-none">var num = 10;var result = num &gt; 5 ? 'Yes' : 'No'; // Yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p>switch 语句也是多分支语句，它用于基于不同的条件来执行不同的代码。当要针对变量设置一系列的特定值的选项时，就可以使用 switch 语句。</p><p>执行思路：利用我们的表达式的值和 case 后面的选项值进行对比，如果匹配，就执行该 case 里的语句，如果都不匹配，则执行 default 里的语句。( 如无 default 则什么都不执行 )</p><pre class="line-numbers language-none"><code class="language-none">switch(表达式) {  case value1:    执行语句1;    break;  case value2:    执行语句2;    break;  ...  default:    最后的执行语句;}switch (2) {  case 1:    document.write('1');    break;  case 2:    document.write('2');    break;  default:    document.write('No Result');}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在开发时，表达式一般会使用变量；</li><li>表达式的值和case里的值必须全等的时候才属于匹配，如 a === 1；</li><li>如果不写条件下的 break 那么代码会一直往下执行；</li></ul><h3 id="if-与-switch-的区别"><a href="#if-与-switch-的区别" class="headerlink" title="if 与 switch 的区别"></a>if 与 switch 的区别</h3><ul><li>一般情况下，他们两个语句可以相互替换；</li><li>switch / case 语句通常在有确定的值的情况下使用；</li><li>if / else 语句通常用于范围判断 ( 大于、等于某个范围等 )；</li><li>switch / case 语句进行条件判断时，会直接执行匹配条件的程序语句，效率更高，而 if / else 语句会逐条进行判断；</li><li>当分支比较少时，if / else 执行效率相对会更高，较多时则 switch / case 语句会效率更高。</li></ul><h2 id="循环流程控制"><a href="#循环流程控制" class="headerlink" title="循环流程控制"></a>循环流程控制</h2><p>目标：</p><ul><li>能够说出循环的目的是什么</li><li>能够说出 for 循环的执行过程</li><li>能够使用断点调试来观察代码的执行过程</li><li>能够使用 for 循环完成累加求和等案例</li><li>能够使用双 for 循环完成乘法表案例</li><li>能够说出 while 循环和 do while 循环的区别</li><li>能够说出 break 和 continue 的区别</li></ul><p>循环的内容</p><ul><li>循环</li><li>for 循环</li><li>双重 for 循环</li><li>while 循环</li><li>do while 循环</li><li>continue 与 break</li></ul><h3 id="什么是循环"><a href="#什么是循环" class="headerlink" title="什么是循环"></a>什么是循环</h3><p>循环的目的是可以重复执行某些代码，JS 中主要有三种类型的循环语句，分别是 for 循环、while 循环、do … while 循环。</p><p>在程序中，一组被重复执行的语句被称为循环体，能否继续重复执行，取决于循环的终止条件。由循环体及循环的终止条件组成的语句，被称为 循环语句。</p><h3 id="for-循环（重点）"><a href="#for-循环（重点）" class="headerlink" title="for 循环（重点）"></a>for 循环（重点）</h3><p>重复执行某些代码，通常与计数有关系</p><pre class="line-numbers language-none"><code class="language-none">// 以下三个选项一个不能少for(初始化变量; 条件表达式; 操作表达式) {  ...}// 示例for (var i = 1; i &lt;= 100; i++) {    document.write('Hello');}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>初始化变量，就是用 var 声明的一个普通变量，通常用于作为计数器使用；</li><li>条件表达式，就是用来决定每一次循环是否继续执行，也就是终止条件；</li><li>操作表达式，是每次循环最后执行的代码，经常用于我们计数器变量进行更新（递增或递减）。</li></ul><p><strong>for 循环的执行过程</strong></p><ol><li>首先执行初始化的变量，但这句话在 for 循环里只执行一次；</li><li>接着去条件表达式里去判断是否满足条件，如果满足条件则进入第三步，如果不满足则退出循环；</li><li>执行循环体；</li><li>接着执行操作表达式，然后再进入步骤2进行判断，如果条件满足则继续循环，如果不满足则退出循环体。</li></ol><p><strong>断点调试</strong></p><p>断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停止，然后你可以一步步往下调试，调试过程中可以看到各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。</p><p>断点调试可以帮组我们观察程序的运行过程，浏览器中检查代码 – sources – 找到需要调试的文件 – 在程序的某一行设置断点-刷新浏览器</p><p>代码调试的能力非常重要，只有学会了代码调试，才能学会自己解决bug的能力。</p><p><strong>双重 for 循环</strong></p><p>很多情况下，单层 for 循环并不能满足我们的需求，比如我们要打印一个5行5列的五角星，打印一个倒三角形等，此时就可以通过循环嵌套来实现。</p><pre class="line-numbers language-none"><code class="language-none">for(外层初始化变量; 外层条件表达式; 外层操作表达式) {    for(里层初始化变量; 里层条件表达式; 里层操作表达式) {        ...    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>我们可以把里面的循环当作外层循环的执行语句；</li><li>外层循环循环一次，里面的循环执行全部。</li></ul><pre class="line-numbers language-none"><code class="language-none">for (var i = 1; i &lt;= 3; i++) {    for (var j = 1; j &lt;= 3; j++) {        console.log('Outter' + i);        for (var j = 1; j &lt;= 3; j++) {            console.log('Inner' + j);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">var str = '';for (var i = 1; i &lt;= 10; i++) {    for (var j = 1; j &lt;= 11 - i; j++) {        str = str + "A"    }    str = str + '\n'}console.log(str);// 结果AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p>while 语句可以在条件表达式为真的前提下，循环执行指定的一段代码，直到表达式不为真的时候结束循环。</p><pre class="line-numbers language-none"><code class="language-none">while (条件表达式) {  ...}// 示例var num = 1;while (num &lt;= 100) {    console.log('PUJI');    num++;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行思路</p><ol><li>先执行条件表达式，如果结果为 true ，则执行循环体代码，如果为 false，则退出循环</li><li>执行循环体代码</li><li>循环体代码执行完毕后，程序会返回第一步继续进行判断，直到循环条件为 false时，循环结束。</li></ol><ul><li>里面应该有计数器（初始化变量）</li><li>循环体中需要有操作表达式，完成计数器的更新，防止死循环</li></ul><p>for 与 while 循环之间的区别</p><ul><li>while 循环可做比 for 循环更复杂的选项</li></ul><h3 id="do-…-while-循环"><a href="#do-…-while-循环" class="headerlink" title="do … while 循环"></a>do … while 循环</h3><p>do … while 语句其实是 while 语句的一个变体，该循环会先执行一次代码块，然后对条件表达式进行判断，如果条件为真，就会重复执行循环体，否则退出循环。</p><pre class="line-numbers language-none"><code class="language-none">do {    ...} while(条件表达式)var i = 1;do {    console.log('PUJI');    i++;} while ( i &lt;= 100 )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>循环小结</p><ul><li>js中循环分为三种，分别是 for、while、do while；</li><li>三个循环很多情况下都可以相互替代使用；</li><li>如果是用来计算次数，跟数字相关的，三者使用基本相同，只是 for 更常用；</li><li>while 和 do while 可以做更复杂的判断条件，比for循环更灵活；</li><li>while 和 do while 执行顺序不一样，while先判断后执行，do while先执行一次在判断是否继续执行</li></ul><h3 id="continue-与-break"><a href="#continue-与-break" class="headerlink" title="continue 与 break"></a>continue 与 break</h3><p>continue 关键字用于立即跳出本次循环，继续下一次循环（本次循环体中continue之后的代码就会少执行一次）。</p><p>break 关键字用于立即跳出整个循环（循环结束）</p><pre class="line-numbers language-none"><code class="language-none">// continue 的使用for (var i = 1; i &lt;= 5; i++) {    if (i == 3) {        continue;    }    console.log(i);} // 1,2,4,5// break 的使用for (var i = 1; i &lt;= 5; i++) {    if (i == 3) {        break;    }    console.log(i);} // 1,2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="迭代器-Iterator-ES6"><a href="#迭代器-Iterator-ES6" class="headerlink" title="迭代器 (Iterator) ES6"></a>迭代器 (Iterator) ES6</h2><p>视频教程：<a href="https://www.bilibili.com/video/BV1uK411H7on?p=18">https://www.bilibili.com/video/BV1uK411H7on?p=18</a></p><p>迭代器是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构之遥部署 Iterator 接口，就可以完成遍历操作。Iterator 接口也就是对象中的一个名为 Symbol.iterator 的属性。ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 使用。迭代器的用途主要用于自定义去遍历数组。</p><p>原生具备 Iterator 接口的数据（可用 for…of 遍历）</p><ul><li>数组 Array</li><li>Arguments 参数</li><li>Set</li><li>Map</li><li>String 字符串</li><li>TypedArray</li><li>NodeList</li></ul><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><ul><li>创建一个指针对象，指向当前数据结构的起始位置；</li><li>第一次调用对象的 next 方法，指针自动指向数据结构的第一个成员；</li><li>接下来不断调用 next 方法，指针一直往后移动，知道指向最后一个成员</li><li>每次调用 next 方法返回一个包含 value 和 done 属性的对象</li></ul><h3 id="for-…-of"><a href="#for-…-of" class="headerlink" title="for … of"></a>for … of</h3><p>与 for … in 不同，of 后面返回的是值，而 in 后面返回的是属性名</p><pre class="line-numbers language-none"><code class="language-none">for(let v of value) {  ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>视频教程：<a href="https://www.bilibili.com/video/BV1uK411H7on?p=20">https://www.bilibili.com/video/BV1uK411H7on?p=20</a></p><p>生成器是一个函数，是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。是一个纯回调函数</p><pre class="line-numbers language-none"><code class="language-none">// 声明function * gen() {  yield 111;  yield 222;  yield 333;}// 调用let iterator = gen();iterator.next();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">function getUsers() {    setTimeout(() =&gt; {        let data = '用户数据';        iterator.next(data);    }, 1000)}function getOrders() {    setTimeout(() =&gt; {        let data = '订单数据';        iterator.next(data);    }, 1000)}function getGoods() {    setTimeout(() =&gt; {        let data = '商品数据';        iterator.next(data);    }, 1000)}function * gen() {    let users = yield getUsers();    console.log(users);    let orders = yield getOrders();    console.log(orders);    let goods = yield getGoods();    console.log(goods);}let iterator = gen();iterator.next();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Promise-重要-ES6"><a href="#Promise-重要-ES6" class="headerlink" title="Promise (重要) ES6"></a>Promise (重要) ES6</h2><p>视频教程：<a href="https://www.bilibili.com/video/BV1uK411H7on?p=24">https://www.bilibili.com/video/BV1uK411H7on?p=24</a></p><p>Promise 是 ES6 引入的异步编程的新解决方案。语法上 Promise 是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果。</p><ul><li>Promise 构造函数：Promise (excutor) {}</li><li>Promise.prototype.then 方法</li><li>Promise.prototype.catch 方法</li></ul><h2 id="集合-Set-ES6"><a href="#集合-Set-ES6" class="headerlink" title="集合 (Set) ES6"></a>集合 (Set) ES6</h2><p>视频教程：<a href="https://www.bilibili.com/video/BV1uK411H7on?p=30">https://www.bilibili.com/video/BV1uK411H7on?p=30</a></p><p>ES6 提供了新的数据结构 Set 。它类似于数组，但成员的值都是唯一的，集合实现了 Iterator 接口，所以可以使用扩展运算符和 for… of 进行遍历，集合的属性和方法：</p><ul><li>size 返回集合的元素个数</li><li>add 增加一个新元素，返回当前集合</li><li>delete 删除元素，返回布尔值</li><li>has 检测集合中是否包含某个元素，返回布尔值</li></ul><h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><pre class="line-numbers language-none"><code class="language-none">// 声明一个集合let s = new Set(['Digital','Branding','Coding']);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="添加元素-add"><a href="#添加元素-add" class="headerlink" title="添加元素 add"></a>添加元素 add</h3><pre class="line-numbers language-none"><code class="language-none">s.add('UI&amp;UX');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="删除元素-delete"><a href="#删除元素-delete" class="headerlink" title="删除元素 delete"></a>删除元素 delete</h3><pre class="line-numbers language-none"><code class="language-none">s.delete('UI&amp;UX');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="检测-has"><a href="#检测-has" class="headerlink" title="检测 has"></a>检测 has</h3><h3 id="集合长度size"><a href="#集合长度size" class="headerlink" title="集合长度size"></a>集合长度size</h3><h3 id="清空集合"><a href="#清空集合" class="headerlink" title="清空集合"></a>清空集合</h3><pre class="line-numbers language-none"><code class="language-none">s.clear();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Map-ES6"><a href="#Map-ES6" class="headerlink" title="Map (ES6)"></a>Map (ES6)</h2><p>ES6 提供了 Map 数据结构，它类似于对象，也是键值对的形式，但是键的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map 也实现了 iterator 接口，所以可以使用扩展运算符和 for…of 进行遍历。Map 的属性和方法</p><ul><li>size</li><li>set</li><li>get</li><li>has</li><li>clear</li></ul><h2 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 (Array)"></a>数组 (Array)</h2><p>目的：</p><ul><li>知道为什么要有数组</li><li>能够创建数组</li><li>能够获取数组中的元素</li><li>能够对数组进行遍历</li><li>能够给数组新增一个元素</li></ul><p>数组 ( Array ) 是指将一组相关的数据存储在单个变量名下的集合，其中每个数据被称为元素，在数组中可以存放任意类型的元素。</p><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p>数组的创建方式有两种，一种是通过new关键字创建数组，一种是利用数组字面量 ‘[ ]’ 创建数组，两种创建方式的结果相同。</p><pre class="line-numbers language-none"><code class="language-none">// 利用 new 关键字创建数组var arr = new Array(); // 创建了一个空的数组var arr = new Array(2); // 表示数组长度为2的空数组var arr = new Array(2,3); // 表示有2个数组元素，分别是2, 3// 利用数组字面量创建数组（常用）var 变量名 = []; // 创建了一个空的数组// 示例var arr = [1, 2, 'PUJI Design', true];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>声明数组并赋值，我们称为数组的初始化</li><li>数组里的数据一定使用逗号来分隔</li><li>数组里的数据被称为数组元素</li></ul><h3 id="检测是否为数组"><a href="#检测是否为数组" class="headerlink" title="检测是否为数组"></a>检测是否为数组</h3><pre class="line-numbers language-none"><code class="language-none">var arr = [1,2,3];// 方法1arr instanceof Array; // true// 方法2Array.isArray(arr); // true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组的索引"><a href="#数组的索引" class="headerlink" title="数组的索引"></a>数组的索引</h3><p>索引 ( 下标 )：用来访问数组元素的序号（数组下标从0开始）。数组可以通过索引来访问、设置和修改对应的数组元素。如果数组中没有对应的元素，则输出 undefined。</p><pre class="line-numbers language-none"><code class="language-none">数组名[索引]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="获取数组元素"><a href="#获取数组元素" class="headerlink" title="获取数组元素"></a>获取数组元素</h3><pre class="line-numbers language-none"><code class="language-none">var arr = [1, 2, 'PUJI Design', true];console.log(arr[2]); // PUJI Design<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="获取数组长度-length"><a href="#获取数组长度-length" class="headerlink" title="获取数组长度 .length"></a>获取数组长度 .length</h3><p>使用 “数组名.length” 可以获取数组元素的长度 （数量）。</p><pre class="line-numbers language-none"><code class="language-none">var arr = [1, 2, 'PUJI Design', true];console.log(arr.length);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="新增-x2F-修改数组元素"><a href="#新增-x2F-修改数组元素" class="headerlink" title="新增/修改数组元素"></a>新增/修改数组元素</h3><p>通过修改length长度增加数组元素，也可以通过数组的索引号的方式追加或修改数组元素。还可使用 push() / pop() 方法对数组元素进行修改</p><pre class="line-numbers language-none"><code class="language-none">// 新增元素 方法1var arr = [1, 2, 3]; // 声明一个数组变量arr.length = 4; // 增加数组长度arr[3] = 4; // 给新增的数组元素赋值// 新增元素 方法2（追加数组元素）var arr = [1, 2, 3];arr[3] = 4;// 修改元素var arr = [1, 2, 3];arr[0] = 4;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="遍历数组（重要）"><a href="#遍历数组（重要）" class="headerlink" title="遍历数组（重要）"></a>遍历数组（重要）</h3><p>遍历数组，也就是把数组中的每一个元素从头到尾都访问一次。同样可以通过 forEach() 方法进行遍历。</p><pre class="line-numbers language-none"><code class="language-none">var arr = [1, 2, 'PUJI Design', true];for (var i = 0; i &lt; 4; i++) {    console.log(arr[i]);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>因为数组索引号是从 0 开始，所以i初始值为0；</li><li>输出的时候 arr[i]</li></ul><h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><p>在一个数组中筛选大于等于10的数字放入一个新的数组</p><pre class="line-numbers language-none"><code class="language-none">// 方法1var arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7];var newArr = [];var j = 0;for (i = 0; i &lt; arr.length; i++) {    if (arr[i] &gt;= 10) {        newArr[j] = arr[i];        j++;    }}console.log(newArr);// 方法2var arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7];var newArr = [];for (i = 0; i &lt; arr.length; i++) {    if (arr[i] &gt;= 10) {        newArr[newArr.length] = arr[i];    }}console.log(newArr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组排序（冒泡排序）"><a href="#数组排序（冒泡排序）" class="headerlink" title="数组排序（冒泡排序）"></a>数组排序（冒泡排序）</h3><p>冒泡排序是一种简单的排序算法，把一系列的数据按照一定的顺序进行排列显示（从小到大或从大到小）。可使用 sort() 方法更方便进行排序。</p><pre class="line-numbers language-none"><code class="language-none">var arr = [5, 4, 3, 2, 1];for (var i = 0; i &lt; arr.length - 1; i++) {  for (var j = 0; j &lt; arr.length - i - 1; j++) {    if (arr[j] &gt; arr[j + 1]) {      var temp = arr[j];      arr[j] = arr[j + 1];      arr[j + 1] = temp;    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>外层循环控制交换的轮数</li><li>内层循环控制每轮交换的次数</li></ul><h3 id="push-x2F-pop"><a href="#push-x2F-pop" class="headerlink" title="push() / pop()"></a>push() / pop()</h3><pre class="line-numbers language-none"><code class="language-none">// push() 在数组的末尾添加一个或多个数组元素var arr = [1,2,3];arr.push(4, 'PUJI');console.log(arr); // [1, 2, 3, 4, 'PUJI']// unshift 在数组的开头添加一个或多个数组元素var arr = [1,2,3];arr.unshift(4, 'PUJI');console.log(arr); // [4, 'PUJI', 1, 2, 3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>push / unshift是可以给数组追加新的元素</li><li>push() / unshift() 参数直接写数组元素</li><li>push / unshift 完毕后，返回的结果是新数组的长度</li></ul><pre class="line-numbers language-none"><code class="language-none">// pop() 可以删除数组的最后一个元素var arr = [1,2,3];arr.pop();console.log(arr); // [1, 2]// shift() 可以删除数组的第一个元素var arr = [1,2,3];arr.shift();console.log(arr); // [2, 3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>pop() / shift() 不带参数，一次只能删除一个元素</li><li>pop() / shift() 的返回值是删除的元素值</li></ul><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p>使用sort() 可以更方便的实现排序功能</p><pre class="line-numbers language-none"><code class="language-none">// 基于个字符串的排序var arr = [5,7,8,6,3,9];arr.sort();// 使用函数进行修改var arr = [12, 5, 7, 36, 9, 6];arr.sort(function(a, b) {    return a - b; // 升序排列， b - a 则降序排列});console.log(arr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="indexOf-x2F-lastIndexOf"><a href="#indexOf-x2F-lastIndexOf" class="headerlink" title="indexOf() / lastIndexOf()"></a>indexOf() / lastIndexOf()</h3><p>indexOf()可以根据数组元素的值查询数组中所在的序列，返回一个序列号值</p><p>indexOf() 和 lastIndexOf() 都是在数组中查询元素对应的序列号，一个是从前面开始查询，一个是从后面开始查询。</p><pre class="line-numbers language-none"><code class="language-none">// 将数组中重复的元素进行筛除var arr = ['c', 'a', 'z', 'a', 'x', 'a', 'x', 'c', 'b'],    newArr = [];for (var i = 0; i &lt; arr.length; i++) {    if (newArr.indexOf(arr[i]) == -1) {        newArr.push(arr[i]);    }}console.log(newArr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组转化为字符串有两种方法</p><pre class="line-numbers language-none"><code class="language-none">// 方法一var arr = [1,2,3];arr.toString(); // 1,2,3// 方法二var arr = [1,2,3];arr.join('-'); // 1-2-3 里面的分隔符可以自定义也可以使用默认<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>用于遍历数组</p><pre class="line-numbers language-none"><code class="language-none">array.forEach(function(currentValue[, indexvar arr = [3, 5, 6, 7, 8, 9, 11, 12, 16, 18];var newArr = arr.some(function(value) {  return value % 3 == 0;})console.log(newArr);, arr]));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>currentValue 数组当前项的值</li><li>index 数组当前项的索引</li><li>arr 数组对象本身</li></ul><pre class="line-numbers language-none"><code class="language-none">var arr = ['Digital', 'Branding', 'Conding'];arr.forEach(function(value, index, array) {  console.log(value + ' : ' + index + ' @ ' + array);});// 返回结果Digital : 0 @ Digital,Branding,Condingmain.js:3 Branding : 1 @ Digital,Branding,Condingmain.js:3 Conding : 2 @ Digital,Branding,Conding<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>根据原有数组返回一个新的数组，需要一个回调函数作为参数，回调函数的返回值称为新数组的元素。</p><p>回调函数中有三个参数</p><ul><li>第一个参数为当前参数</li><li>第二个参数为元素的索引</li><li>第三个参数为当前数组</li></ul><pre class="line-numbers language-none"><code class="language-none">const arr = [1, 2, 3, 4, 5];let result = arr.map(item =&gt; item + 1); // [2, 3, 4, 5, 6]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中复合条件的所有元素，主要用于筛选数组。</p><pre class="line-numbers language-none"><code class="language-none">array.filter(function(currentValue[, index, arr]));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>currentValue 数组当前项的值</li><li>index 数组当前项的索引</li><li>arr 数组对象本身</li><li>会返回一个新的数组</li></ul><pre class="line-numbers language-none"><code class="language-none">var arr = [3, 5, 6, 7, 8, 9, 11, 12, 16, 18];var newArr = arr.filter(function(value) {  return value % 3 === 0;})console.log(newArr); // 3, 6, 9, 12, 18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h3><p>从数组中找到一个符合条件的第一个值。</p><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p>用来合并数组中的元素。</p><h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><p>用于检测数组中的元素是否满足指定条件，通俗点说，就是查找数组中是否有满足条件的元素，返回结果是一个布尔值。</p><pre class="line-numbers language-none"><code class="language-none">array.filter(function(currentValue, index[, arr]));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>currentValue 数组当前项的值</li><li>index 数组当前项的索引</li><li>arr 数组对象本身</li><li>返回一个布尔值，如果查找到返回 true，否则返回 false</li><li>如果找到第一个满足条件的元素，则终止循环</li></ul><pre class="line-numbers language-none"><code class="language-none">var arr = [3, 5, 6, 7, 8, 9, 11, 12, 16, 18];var flag = arr.some(function(value) {  return value % 3 == 0;})console.log(flag); // true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><h2 id="函数-Function"><a href="#函数-Function" class="headerlink" title="函数 (Function)"></a>函数 (Function)</h2><p>目标</p><ul><li>能说出为什么需要函数</li><li>根据语法书写函数</li><li>能够根据需求封装函数</li><li>能够说出形参和实参的传递过程</li><li>能够使用函数的返回值</li><li>能够使用arguments获取函数的参数</li><li>能够说出函数的多种定义和调用方式</li><li>能够说出和改变函数内部 this 的指向</li><li>能够说出严格模式的特点</li><li>能够把函数作为参数和返回值传递</li><li>能够说出闭包的作用</li><li>能够说出递归的两个条件</li><li>能够说出深拷贝和浅拷贝的区别</li></ul><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>在js里，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用，这种情况下使用函数就可以解决复用的问题。函数就是封装了一段可重复调用执行的代码块，通过此代码块可实现代码的多次重复使用。</p><ul><li>每个函数都有一个原型对象</li></ul><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><p>视频教程：<a href="https://www.bilibili.com/video/BV17y4y1J7L1?p=51">https://www.bilibili.com/video/BV17y4y1J7L1?p=51</a></p><p>函数的声明方式有三种方式，使用 function 关键字进行申明（命名函数），使用函数表达式进行申明（匿名函数），利用构造函数创建函数对象实例。</p><p>函数属于对象类型</p><pre class="line-numbers language-none"><code class="language-none">// 自定义函数（命名函数）function 函数名() {  ...}// 函数表达式（匿名函数）var fn = function () {  ...}// 利用构造函数创建函数对象实例 (效率较低，不常用)var fn = new Function('参数1', '参数2', '函数体')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><p>视频教程：<a href="https://www.bilibili.com/video/BV17y4y1J7L1?p=52">https://www.bilibili.com/video/BV17y4y1J7L1?p=52</a></p><pre class="line-numbers language-none"><code class="language-none">// 调用普通函数(以上三种形式创建的函数都是普通函数)fn();// 调用对象函数var obj = {  fn: function() {    ...  }}obj.fn();// 调用构造函数function Fn() {  ..}new Fn();// 除以上三种形式外，还包括事件绑定函数、定时器函数、立即执行函数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>函数是执行某件事情，函数名一般使用动词</li><li>声明函数本身不会执行，只有调用了函数才会执行</li></ul><p>进阶参考： <a href="https://lab.puji.design/javascript-four-method-of-function-call-mode/">JS 中四种函数的调用模式</a></p><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p>函数的参数分为两种类型，形参与实参，在声明函数的圆括号里的参数称为形参，在函数调用的圆括号里的参数称为实参。</p><pre class="line-numbers language-none"><code class="language-none">// 声明函数function 函数名(形参1, 形参2, ...) {  //函数体}// 调用函数函数名(实参1,实参2, ...);// 示例function test(a,b,c) {  return a + b + c;}test(1,2,3);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>形参是接收实参的，可以看作是一个不用声明的变量</li><li>函数可以带参数也可以不带，并且带参数时数量不限</li><li>多个参数之间使用逗号分隔</li><li>如果形参与实参的数量一致，则正常输出结果</li><li>如果实参的数量多余形参的数量，会取到形参的数量进行执行</li><li>如果实参的数量少余形参的数量，多余的形参会被定义为 undefined</li><li>建议尽量让形参与实参的数量一致</li></ul><h3 id="参数的默认值"><a href="#参数的默认值" class="headerlink" title="参数的默认值"></a>参数的默认值</h3><pre class="line-numbers language-none"><code class="language-none">// 示例function test(a,b,c=10) {  return a + b + c;}test(1,2);// 示例 2function connect({host, username, password, port='80'}) {  console.log('ok');}conncet({  host: 'puji.design',  username: 'root',  password: 'root',  port: '8888'})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>参数默认值，一般需要从右往左添加</li><li>参数的默认值可以与解构赋值共同使用</li></ul><h3 id="return-返回值"><a href="#return-返回值" class="headerlink" title="return 返回值"></a>return 返回值</h3><p>将函数的值返回给调用者，此时可以通过使用return语句来实现。</p><pre class="line-numbers language-none"><code class="language-none">function 函数名() {  return 需要返回的结果;}函数名();// 示例function getResult() {  return 'PUJI';}getResult(); // getResult() = 'PUJI'// 示例2var sum = 0;function getSum(num1, num2) {    for (var i = num1; i &lt;= num2; i++) {        sum += i;    }    return sum;}console.log(getSum(1, 100)); // 5050// 示例3function getMax(num1,num2) {  return num1 &gt; num2 ? num1 : num2;}console.log(getMax(1, 100));  // 100// 示例4function getMax(arr) {    var maxNum = arr[0];    for (var i = 1; i &lt; arr.length; i++) {        if (maxNum &lt; arr[i]) {            maxNum = arr[i];        }    }    return maxNum;}console.log(getMax([5, 2, 99, 101, 67, 77]));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>函数只是实现某种功能，最终的结果需要返回给函数的调用者</li><li>只要函数遇到 return ，就把后面的结果返回给函数的调用者</li><li>return 语句有终止函数的作用，遇到 return 之后的代码不被执行</li><li>return 只能返回一个值，如果需要输出多个值，可以利用数组或对象完成</li><li>函数都是有返回值的，如果没有 return 将返回 undefined，有 return 则返回 return 语句中的值</li></ul><h3 id="break-continue-return-的区别"><a href="#break-continue-return-的区别" class="headerlink" title="break, continue, return 的区别"></a>break, continue, return 的区别</h3><ul><li>break:结束当前的循环体（如for，while）</li><li>continue:跳出本次循环，继续执行下一次循环（如for，while）</li><li>return:可在循环或函数中使用，不仅可以退出循环或函数，还能返回return语句中的值</li></ul><h3 id="arguments-参数"><a href="#arguments-参数" class="headerlink" title="arguments 参数"></a>arguments 参数</h3><p>当我们不确定有多少个参数传递的时候，可以用 arguments 来获取，在 javascript中，arguments 实际上它是当前函数的一个内置对象。所有函数都内置了一个arguments 对象，arguments 对象中存储了传递的所有实参。</p><pre class="line-numbers language-none"><code class="language-none">function 函数名(){  arguments; // 里面存储了所有传递过来的实参  arguments.length; // 5  arguments[2]; // 2}函数名(1,2,3,4,5);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>arguments 是以一个伪数组的形式来展示的，伪数组的特点以下：</p><ul><li>具有 length 属性</li><li>按索引方式储存数据</li><li>不具有数组的 push(), pop() 等方法</li></ul><h3 id="rest-参数-ES6"><a href="#rest-参数-ES6" class="headerlink" title="rest 参数 (ES6)"></a>rest 参数 (ES6)</h3><p>用于获取函数的实参，代替 arguments</p><pre class="line-numbers language-none"><code class="language-none">function date(...args){  console.log(args);}date(1,2,3); // 返回[1,2,3]function date(a,b,...args){  console.log(args);}date(1,2,3,4,5,6); // 返回[3,4,5,6]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>rest 参数前面为三个 … 后面为自定义的标识符；</li><li>rest 参数返回的是一个数组，而 argument 返回的是一个对象;</li><li>rest 参数必须放到参数的最后。</li></ul><h3 id="函数可以调用其他函数"><a href="#函数可以调用其他函数" class="headerlink" title="函数可以调用其他函数"></a>函数可以调用其他函数</h3><p>因为每个函数都是独立的代码块，用于完成特殊任务，因此经常会用到函数互相调用的情况。</p><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>前面一种函数的声明方式，也叫命名函数，以下的函数声明，fn只是变量名，因此此函数没有名称，也叫匿名函数。</p><pre class="line-numbers language-none"><code class="language-none">// 函数表达式(匿名函数)var 变量名 = function(){};// 示例var fn = function(){};// 调用函数fn();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>函数没有名称，声明的名称属于变量名</li><li>函数表达式声明方式与声明变量差不多，只不过变量里存的是值，而函数表达式里存的是函数</li><li>同样可以进行参数的传递</li></ul><h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>一般的函数声明后需调用才可执行，而立即执行函数无需调用立马可以执行。主要创建一个独立的作用域</p><pre class="line-numbers language-none"><code class="language-none">// 写法 1(function() {})();// 写法 2(function() {}());(function(a, b) {  console.log(a + b);})(1, 2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>立即执行函数也可以进行参数传递</li><li>立即执行函数可以是匿名函数，也可以命名；</li><li>他的最大作用就是独立创建了一个作用域</li></ul><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出。</p><pre class="line-numbers language-none"><code class="language-none">// 接收函数作为参数function fn(callback) {  callback &amp;&amp; callback();}fn(function() {alert('PUJI')});// 将函数作为返回值输出function fn(callback) {  return function() {}}fn();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="箭头函数-ES6"><a href="#箭头函数-ES6" class="headerlink" title="箭头函数 (ES6)"></a>箭头函数 (ES6)</h3><p>bilibili 视频教程：<a href="https://www.bilibili.com/video/BV1bS4y1b7NV?p=5">https://www.bilibili.com/video/BV1bS4y1b7NV?p=5</a></p><p>ES6 允许使用箭头 =&gt; 定义函数</p><pre class="line-numbers language-none"><code class="language-none">// 以前声明函数的方法var fn = function() {  ..}// 箭头简化写法let fn = () =&gt; {  ..}// 省略小括号let fn = n =&gt; {  return n;}console.log(fn(3));// 省略花括号let fn = (n) =&gt; n * n;console.log(fn(3));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">// this 指向声明函数的作用域let ad = document.querySelector('div');ad.addEventListener('click', function(){  setTimeout(() =&gt; {    this.style.background = 'blue';  },1000);});// 代码简化const arr = [1,2,3,4,5,6,9];const result = arr.filter( item =&gt; item % 2 === 0; )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>箭头函数的 this 是静态的，this 始终指向函数声明时所在作用域下的 this 的值；</li><li>不能作为构造函数实例化对象；</li><li>不能使用 arguments 变量；</li><li>当形参有且只有一个的时候可以省略小括号；</li><li>当执行体只有一条语句的时候可以省略花括号，并且 return 也必须省略；</li><li>箭头函数适合与 this 无关的回调、定时器、数组的方法回调。</li></ul><h3 id="函数的-this-指向"><a href="#函数的-this-指向" class="headerlink" title="函数的 this 指向"></a>函数的 this 指向</h3><p>视频教程：<a href="https://www.bilibili.com/video/BV17y4y1J7L1?p=53">https://www.bilibili.com/video/BV17y4y1J7L1?p=53</a></p><p>this 的指向，是当我们调用函数的时候确定的，调用方式的不同决定了 this 的指向不同，一般指向我们的调用者</p><table><thead><tr><th>调用方式</th><th>this 指向</th></tr></thead><tbody><tr><td>普通函数调用</td><td>普通模式：window 严格模式：undefine</td></tr><tr><td>构造函数调用</td><td>实例对象，原型对象里的方法也指向实例对象。</td></tr><tr><td>对象方法调用</td><td>该方法所属对象</td></tr><tr><td>事件绑定调用</td><td>绑定事件对象</td></tr><tr><td>定时器函数</td><td>window</td></tr><tr><td>立即执行函数</td><td>window</td></tr></tbody></table><p>JavaScript 为我们提供了一些函数方法来帮我们处理函数内部 this 的指向问题，常用的有 bind()、call()、apply() 三种方法。</p><h3 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h3><p>视频教程：<a href="https://www.bilibili.com/video/BV17y4y1J7L1?p=34">https://www.bilibili.com/video/BV17y4y1J7L1?p=34</a><br>视频教程：<a href="https://www.bilibili.com/video/BV17y4y1J7L1?p=54">https://www.bilibili.com/video/BV17y4y1J7L1?p=54</a></p><p>可以调用这个函数，并且修改函数运行时的 this 指向</p><pre class="line-numbers language-none"><code class="language-none">fn.call(thisAsg, arg1, arg2, ...);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>thisArg: 当前调用函数 this 的指向对象</li><li>arg1, arg2: 传递的其他参数</li></ul><pre class="line-numbers language-none"><code class="language-none">// 常规调用方法function fn() {  console.log('PUJI');}fn();// 使用 call() 方法进行调用function fn() {  console.log(this);}fn.call(); // this 指向 window// 修改 this 指向function fn() {  console.log(this.name);}var o = {  name: 'PUJI'}fn.call(o); // 此时这个函数的 this 就指向了 o 这个对象// 传递参数function fn(a, b) {  console.log(this.name);  console.log(a + b);}var o = {  name: 'PUJI'}fn.call(o, 1, 2); // call 只是修改 this 的指向，指向的对象不参与参数的传递<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>call() 方法可以调用函数</li><li>改变函数运行时的 this 指向</li><li>他的主要作用是可以实现继承</li></ul><h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p>视频教程：<a href="https://www.bilibili.com/video/BV17y4y1J7L1?p=55">https://www.bilibili.com/video/BV17y4y1J7L1?p=55</a></p><p>利用 apply() 方法调用一个函数，简单理解为调用函数的方式，但是他可以改变函数的 this 指向</p><pre class="line-numbers language-none"><code class="language-none">fn.apply(thisArg, [argsArray])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>thisArg: 在函数运行时指定的 this 值</li><li>argsArray: 传递的值，必须包含在数组里</li><li>返回值就是函数的返回值，因为他就是调用函数</li></ul><pre class="line-numbers language-none"><code class="language-none">var o = {  name: 'PUJI'}function fn(arr) {  console.log(arr);}fn.apply(o, ['Design']); // 返回字符串// 借助于数学内置对象求最大值var arr = [1,2,3,5,6,9];var result = Math.max.apply(Math, arr);console.log(result);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>也是调用函数，同样可以改变函数内部的 this 指向</li><li>但是他的参数必须是数组（伪数组）</li><li>返回的值是一个字符串</li><li>主要作用，比如可以利用 apply 借助于数学内置对象求最大值</li></ul><h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><p>视频教程：<a href="https://www.bilibili.com/video/BV17y4y1J7L1?p=57">https://www.bilibili.com/video/BV17y4y1J7L1?p=57</a></p><p>bind() 不会调用函数，但是能改变函数内部 this 指向</p><pre class="line-numbers language-none"><code class="language-none">fn.bind(thisArg, arg1, arg2, ...);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">var o = {  name: 'PUJI'}function fn() {  console.log(this);}var f = fn.bind(o);f();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>thisArg: 函数运行时 this 的指向对象</li><li>arg1, arg2: 传递的其他参数</li><li>不会调用原来的函数，可以改变原来函数内部的 this 指向</li><li>返回由指定的 this 值和初始化参数改造的原函数拷贝</li></ul><pre class="line-numbers language-none"><code class="language-none">// bind 应用案例示例var btn = document.querySelector('button');btn.addEventListener('click', function() {  this.disabled = true;  setTimeout(function () {    this.disabled = false; // 此时定时器里的 this 指向的是 btn 而不是 window 了  }.bind(this), 3000);})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p><a href="https://www.bilibili.com/video/BV17y4y1J7L1?p=70">https://www.bilibili.com/video/BV17y4y1J7L1?p=70</a></p><p>如果一个函数在内部可以调用其自身，那么这个函数就是递归函数。递归函数的作用和循环效果一样。由于递归很容易发生”栈溢出”错误 ( Stack overflow )，所以必须加上退出条件 return。</p><pre class="line-numbers language-none"><code class="language-none">function fn() {  if() {    return;  }  fn();  }fn();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="利用递归函数求数学题"><a href="#利用递归函数求数学题" class="headerlink" title="利用递归函数求数学题"></a>利用递归函数求数学题</h4><pre class="line-numbers language-none"><code class="language-none">// 示例 1function fn(n) {  if(n === 1) {    return 1;  }  return n * fn(n - 1);}fn(6);// 示例 2function fn(n) {  if(n ===1 || n === 2) {    return 1;  }  return fn(n - 1) + fn(n - 2);}fn(6)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="利用递归函遍历数据"><a href="#利用递归函遍历数据" class="headerlink" title="利用递归函遍历数据"></a>利用递归函遍历数据</h4><pre class="line-numbers language-none"><code class="language-none">var data = [  {    id: 1,    name: 'Design',    cats: [      {        id: 11,        name: 'UI&amp;UX'      }, {        id: 12,        name: 'Branding'      }, {        id: 13,        name: 'Website'      }    ]  },  {    id: 2,    name: 'Coding'  }]var o = {};function getID(json, id) {  json.forEach( element =&gt; {    if(element.id === id) {      o = element      return element;    } else if ( element.cats &amp;&amp; element.cats.length &gt;0 ) {      o = getID( element.cats, id);          }  });  return o;}console.log(getID(data, 11));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="检测属性"><a href="#检测属性" class="headerlink" title="检测属性"></a>检测属性</h2><pre class="line-numbers language-none"><code class="language-none">let arr = ['PUJI', 'Design']console.log(arr.hasOwnProperty('length')) // 只检测自己是否有此属性console.log('length' in arr) // 检测自己以及父级是否有此属性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>目标：</p><ul><li>能够说出 javascript 的两种作用域</li><li>能够区分全局变量和局部变量</li><li>能够说出如何在作用域链中查找变量的值</li></ul><h3 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h3><p>一段程序代码中所用到的名字并不总是有效可用的，而限定这个名字的可作用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，更重要的是减少了名字的冲突。</p><p>js的作用域分为两种 (es6 之前)</p><ul><li>全局作用域：在文件的最外层定义的变量就是在全局作用域里</li><li>局部作用域：在函数内定义的变量就是局部作用域，这个代码名字只在函数内部起效果，因此也叫函数作用域。</li></ul><pre class="line-numbers language-none"><code class="language-none">var a = 10;function fn() {  var b = 20;}// a 为全局作用域的变量，b 为局部作用域的变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>全局作用域与局部作用域的相同的变量不会相互影响</li></ul><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>在javascript中，根据作用域的不同，变量也可以分为全局变量与局部变量</p><ul><li>全局变量：在全局作用域下的变量就是全局变量，在全局下都可使用</li><li>局部变量：在局部作用域下的变量，或者说是在函数内部的变量就是局部变量</li></ul><pre class="line-numbers language-none"><code class="language-none">var a = 1;function fn() {  var b = 2;  c = 3;}// a全局变量// b局部变量// c全局变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果在函数内部没有声明直接赋值的变量，也属于全局变量</li><li>函数的形参也可以看作局部变量</li><li>从执行效率来看，全局变量只有浏览器关闭的时候才会销毁，比较占内存资源，局部变量当程序执行完毕就会销毁，比较节约内存资源</li></ul><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>根据内部函数可以访问外部函数变量变量的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链，作用域链采用就近原则，即查找到最近一层的数据后就停止再向外去找</p><h3 id="块级作用域-ES6"><a href="#块级作用域-ES6" class="headerlink" title="块级作用域 (ES6)"></a>块级作用域 (ES6)</h3><p>使用花括号 {} 包裹，里面的作用域就属于块级作用域，块级作用域里的变量，只在当前块中有效。块级作用域的好处在于，如果项目比较复杂的情况下，有内层变量覆盖外层变量的风险。</p><pre class="line-numbers language-none"><code class="language-none">if(true) {  块级作用域}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="闭包-Closure"><a href="#闭包-Closure" class="headerlink" title="闭包 (Closure)"></a>闭包 (Closure)</h2><p>视频教程：<a href="https://www.bilibili.com/video/BV17y4y1J7L1?p=63">https://www.bilibili.com/video/BV17y4y1J7L1?p=63</a></p><p>闭包是指有权<strong>访问另一个函数作用域</strong>中变量的<strong>函数</strong>。简单理解就是，一个作用域可以访问另外一个函数内部的局部变量。闭包的作用是延伸了变量的作用范围。</p><h3 id="案例示范"><a href="#案例示范" class="headerlink" title="案例示范"></a>案例示范</h3><h4 id="循环注册点击事件"><a href="#循环注册点击事件" class="headerlink" title="循环注册点击事件"></a>循环注册点击事件</h4><pre class="line-numbers language-none"><code class="language-none">// 手动获取索引号方式var items = document.querySelectorAll('li');for ( i = 0; i &lt; items.length; i++ ) {  items[i].index = i; // 获取索引号  items[i].addEventListener('click', function () {    console.log(this.index);  })}// 利用闭包方式获得索引号 (相比第一种效率更低)var items = document.querySelectorAll('li');for ( i = 0; i &lt; items.length; i++ ) {  // 利用 for 循环创建了多个立即执行函数  (function (i) {    items[i].addEventListener('click', function () {      console.log(i);    })  })(i);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="循环中的-setTimout"><a href="#循环中的-setTimout" class="headerlink" title="循环中的 setTimout()"></a>循环中的 setTimout()</h4><pre class="line-numbers language-none"><code class="language-none">var items = document.querySelectorAll('li');for ( i = 0; i &lt; items.length; i++ ) {  (function (i) {    setTimeout(function() {      console.log(i);    }, 3000);  })(i);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="出租车计价案例"><a href="#出租车计价案例" class="headerlink" title="出租车计价案例"></a>出租车计价案例</h4><pre class="line-numbers language-none"><code class="language-none">var car = (function() {  var start = 13;  var total = 0;  return {    price: function(n) {      if(n &lt;= 3) {        total = start;      } else {        total = start + (n-3)*5      }      return total;    },  }})();console.log(car.price(6));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h2><p>浅拷贝只是拷贝一层，更深层次的对象级别的只拷贝引用。深拷贝可拷贝多层，每一层级的数据都会被拷贝。</p><p>在 ES6 中新增了浅拷贝的方法 Object.assign( target, …sources )</p><pre class="line-numbers language-none"><code class="language-none">// 浅拷贝var obj = {  name: 'PUJI',  age: 36,  cats: {    work1: 'Digital',    work2: 'Branding',    work3: 'Coding'  }};var o = {};for(var k in obj) {  // k 是属性名，obj[k] 是属性值  o[k] = obj[k];}console.log(o);// assign() 方法var obj = {  name: 'PUJI',  age: 36,  cats: {    work1: 'Digital',    work2: 'Branding',    work3: 'Coding'  }};var o = {};Object.assign(o, obj);console.log(o);// 浅拷贝可以拷贝第一层的数据，更深层的对象数据只会拷贝对象的指向地址，所以修改此对象的数据，另一个对象里的数据也会一起更改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">// 深拷贝var obj = {  name: 'PUJI',  age: 36,  cats: {    work1: 'Digital',    work2: 'Branding',    work3: 'Coding'  },  num: [3, 6, 9]};var o = {};function deepCopy(newObj, oldObj) {  for( var k in oldObj ) {    // 判断属性值属于哪种数据类型    var element = oldObj[k];    if( element instanceof Array ) {      newObj[k] = [];      deepCopy(newObj[k], element);    } else if( element instanceof Object ) {      newObj[k] = {};      deepCopy(newObj[k], element);    } else {      newObj[k] = element;    }  }}deepCopy(o, obj)console.log(o);;// 深拷贝可以拷贝所有层级的数据，会把深层级的数据另外开辟一个空间进行存储，所以修改此对象的数据，不会对另一个对象里的数据造成影响<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="对象-Object-重要"><a href="#对象-Object-重要" class="headerlink" title="对象 (Object) (重要)"></a>对象 (Object) (重要)</h2><p>目标</p><ul><li>为什么需要对象</li><li>能够使用字面量创建对象</li><li>能够使用构造函数创建对象</li><li>能够说出 new 的执行过程</li><li>能够遍历对象</li></ul><p>在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，如字符串，数值，数组函数等。对象属于复杂数据类型</p><p>JavaScript 中的对象分为3种：自定义对象、内置对象、浏览器对象。前面两种对象是js基础内容，属于ECMAScript；第三个浏览器对象属于 JS 独有的。</p><h5 id="对象是由属性和方法组成的"><a href="#对象是由属性和方法组成的" class="headerlink" title="对象是由属性和方法组成的"></a>对象是由属性和方法组成的</h5><ul><li>属性：事物的特征，在对象中用属性来表示（常用名次）；</li><li>方法：事物的行为，在对象中用方法来表示（常用动词）。</li></ul><h5 id="为什么需要对象"><a href="#为什么需要对象" class="headerlink" title="为什么需要对象"></a>为什么需要对象</h5><p>在保存一个值时，可以使用变量，保存多个值（一组值）可以使用数组，但如果需要保存多维的数据，JS 中的对象表达结构更清晰，更强大。</p><h3 id="创建对象的三种方式"><a href="#创建对象的三种方式" class="headerlink" title="创建对象的三种方式"></a>创建对象的三种方式</h3><p>在 JavaScript 中 我们可以采用三种方式创建对象</p><ul><li>利用字面量创建对象（常用）:就是花括号 {} 里包含了表达这个具体事物（对象）的属性和方法；</li><li>利用 new Object 创建对象；</li><li>利用构造函数创建对象。</li></ul><h3 id="利用字面量创建对象"><a href="#利用字面量创建对象" class="headerlink" title="利用字面量创建对象"></a>利用字面量创建对象</h3><pre class="line-numbers language-none"><code class="language-none">var obj = {}; // 创建了一个空的对象<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">var obj = {  uname: 'Wewe',  age: 36,  sex: 'male',  sayHi: function() {    ...  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>里面的属性或方法我们采取键值对的形式，即名称与值，值可以是任何类型；</li><li>多个属性或者方法中间用逗号隔开；</li><li>方法冒号后面跟的是一个匿名函数。</li></ul><h3 id="new-关键字创建对象"><a href="#new-关键字创建对象" class="headerlink" title="new 关键字创建对象"></a>new 关键字创建对象</h3><pre class="line-numbers language-none"><code class="language-none">// 利用 new Object 创建对象var obj = new Object(); //创建了一个空的对象obj.uname = 'Wewe';obj.age = 36;obj.sex = 'male'obj.sayHi = function() {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>利用等号赋值的方法添加对象的属性和方法；</li><li>每个属性和方法之间使用分号分隔；</li><li>调用与前面一样。</li></ul><h3 id="利用构造函数创建对象（重要）"><a href="#利用构造函数创建对象（重要）" class="headerlink" title="利用构造函数创建对象（重要）"></a>利用构造函数创建对象（重要）</h3><p>ES6 新增了面向对象的概念，和此方法类似。</p><p>由于前面两种创建对象的方式一次只能创建一个对象，如果需要一次创建多个对象，且很多属性和方法是大致相同的，因此我们可以利用函数的方法重复这些相同的代码，又因为这个函数里面封装的不是普通代码，而是对象，我们就把这个函数称为构造函数。</p><p>构造函数是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里。</p><pre class="line-numbers language-none"><code class="language-none">function 构造函数名() {  this.属性 = 值；  this.方法 = function() {    ...  }}new 构造函数名();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">// 示例function Star(uname, age, sex) {  this.name = uname;  this.age = age;  this.sex = sex;}Star.prototype.sing = function(song) {  console.log(song);}var ldh = new Star('刘德华', '36', '男');ldh.sing('冰雨');var zxy = new Star('张学友', '39', '男');zxy.sing('李香兰');console.log(ldh);console.log(zxy);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>构造函数名字首字母需要大写；</li><li>构造函数中的属性与方法指向构造函数的原型对象；</li><li>通过 new 构造出的子类，将自动同函数的原型对象进行关联；</li><li>每个子类还可拥有自己独立的属性和方法（ 尽量将每个子类相同的方法都放在原型对象里 ）；</li><li>原型对象相当于所有构造出的实例对象的公共区域；</li><li>设置属性时，只能通过原型对象自己去设置这个属性，如 “Star.prototype.name = 123” ;</li><li>如果实例对象设置一个跟原型对象相同属性的值时，会自动添加一个自己的属性，如 “ldh.name = 456” ;</li><li>构造函数中不需要 return 就可以返回结果，返回的结果是 this 对象，如果写了 return 将返回 return 的值；</li><li>我们只要调用一次构造函数就创建了一个新的实例对象</li><li>属性和方法前面必须添加 this</li><li>属性在构造函数中添加，尽量不要在原型中添加属性（ 如果是常量可以添加在原型中 ），方法尽量在原型中添加。</li></ul><pre class="line-numbers language-none"><code class="language-none">// 标准用法结构function Studio() {  this.name = 'PUJI';  this.age = 36;}Studio.prototype.work = function() {  console.log(this.name + this.age + 'years old.');}var a = new Studio();a.work();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">// 改进1，将属性参数化function Studio(name, age) {  this.name = 'PUJI';  this.age = 36;}Studio.prototype.work = function(work) {  console.log(this.name + this.age + 'years old.' + ' And we lover ' + work);}var a = new Studio( 'PUJI', 36 );a.work('Design');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">// 改进2，将参数设为对象function Studio(opt) {  this.name = opt.name;  this.age = opt.age;}Studio.prototype.work = function() {  console.log(this.name + this.age + 'years old.' + ' And we lover ' + work);}var a = new Studio( {  name: 'PUJI',  age: 36} );a.work('Design');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">// 改进3，将属性与方法统一在一个对象function Studio(opt) {    this._init(opt); // 使用下划线定义，用于区分此方法仅在内部使用  }  Studio.prototype = {      constructor: Studio, // 指向回原来的构造函数    _init: function(opt) {      this.name = opt.name;      this.age = opt.age;    },    work: function(work) {      console.log(this.name + this.age + 'years old.' + ' And we lover ' + work);    }  }  var a = new Studio( {    name: 'PUJI',    age: 36,    work: 'Design'  } );  console.log(Studio.prototype.constructor);  console.log(a.__proto__.constructor);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="new-关键词的执行过程"><a href="#new-关键词的执行过程" class="headerlink" title="new 关键词的执行过程"></a>new 关键词的执行过程</h5><ol><li>通过 new 构造子类，生成一个新的实例对象；</li><li>在内存中创建一个空的 this 对象；</li><li>this 对象指向构造函数原型对象；</li><li>执行构造函数里的代码，给 this 对象添加属性和方法。</li></ol><h5 id="构造函数与对象之间的联系"><a href="#构造函数与对象之间的联系" class="headerlink" title="构造函数与对象之间的联系"></a>构造函数与对象之间的联系</h5><ul><li>构造函数是抽象了对象的公共部分，封装到了函数里面，泛指的某一大类，</li><li>对象是特指某一个，通过 new 关键字创建对象的过程我们也称为对象的实例化</li></ul><h3 id="构造函数的成员"><a href="#构造函数的成员" class="headerlink" title="构造函数的成员"></a>构造函数的成员</h3><p>构造函数中的属性和方法都称为成员，成员可以随意添加，成员分为实例成员和静态成员。实例成员就是构造函数内部通过 this 添加的成员，实例成员只能通过实例化的对象来访问。静态成员是在构造函数本身上添加的成员。静态成员只能通过构造函数来访问。</p><pre class="line-numbers language-none"><code class="language-none">function Studio(name) {  this.name = name;}var puji = new Studio('PUJI');console.log(puji.name); // 实例成员只能通过实例化的对象来访问，不可通过构造函数来访问，如 Star.nameStudio.age = 36;console.log(Studio.age); // 静态成员只能通过构造函数来访问，不能通过实例化对象来访问<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="原型-Prototype"><a href="#原型-Prototype" class="headerlink" title="原型 Prototype"></a>原型 Prototype</h3><p>构造函数通过原型分配的函数，是所有对象所共享的。</p><p>JavaScript 规定，每一个构造函数都有一个原型属性，指向另一个对象，这个原型就是一个对象，对象的所有属性和方法都会被构造函数所拥有。我们可以把一些不变的方法，直接定义在原型对象上，这样所有对象的实例就可以共享这些方法。</p><p>一般情况下，我们公共属性定义到构造函数里，方法放在原型对象里。</p><p>实例化的对象系统会自动添加一个 <strong>proto</strong> 原型，指向了构造函数的原型对象 prototype， <strong>proto</strong> 和 prototype 是相同的空间。方法查找规则，先看对象身上是否有此方法，如果有就执行，没有就去原型对象身上去查找。</p><h3 id="添加-x2F-修改-x2F-删除属性"><a href="#添加-x2F-修改-x2F-删除属性" class="headerlink" title="添加/修改/删除属性"></a>添加/修改/删除属性</h3><p>使用 “对象名+属性名” 的方式进行添加或修改属性，也可使用 Object.defineProperty()</p><pre class="line-numbers language-none"><code class="language-none">// 添加属性var obj = {  uname: 'PUJI',  age: 36}obj.sex = 'male';// 修改属性var obj = {  uname: 'PUJI',  age: 36,  sex: 'male'}obj.uname = 'Wewe';// 删除属性var obj = {  uname: 'PUJI',  age: 36,  sex: 'male'}delete obj.sex;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h3><p>调用对象的属性有两种方法，第一种方法采取 “对象名.属性名” 的形式，第二种方法 “对象名[‘属性名’]”，调用对象的方法采用 “对象名.方法名()”</p><pre class="line-numbers language-none"><code class="language-none">// 调用属性方法1obj.age;// 调用属性方法2obj['age'];// 调用方法的方法obj.sayHi();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>变量、属性、函数、方法的区别</p><p>变量和属性都是用于存储数据的，变量单独声明并赋值，使用的时候直接写变量名，属性是在对象里，不需要声明，使用的时候必须是对象.属性名</p><p>函数和方法都是实现某种功能或做某件事，函数是单独声明并且调用的，方法在对象里，无需声明，调用的时候需 对象.方法()</p><h3 id="简化对象写法-ES6"><a href="#简化对象写法-ES6" class="headerlink" title="简化对象写法 (ES6)"></a>简化对象写法 (ES6)</h3><p>允许在花括号里，直接写入变量和函数，作为对象的属性和方法。</p><pre class="line-numbers language-none"><code class="language-none">// 之前的写法var name = 'PUJI';var work = function() {  console.log(name)}var obj = {  name: name,  work: work,  change: function() {    console.log('Design Studio');  }}// ES6 简化写法let name = 'PUJI';let work = function() {  console.log(name)}const obj = {  name,  work, // 属性名和变量名一致时赋值的简化  change() {    console.log('Design Studio'); // 声明方法的简化  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="遍历对象-for-…-in"><a href="#遍历对象-for-…-in" class="headerlink" title="遍历对象 for … in"></a>遍历对象 for … in</h3><p>for … in 语句用于对数组或对象的属性进行循环操作</p><pre class="line-numbers language-none"><code class="language-none">for (变量 in 对象);// 示例var obj = {  uname: 'Wewe',  age: 36,  sex: 'male',  sayHi: function() {    ...  }}for (var k in obj) {  console.log(k); //得到的是属性名  console.log(obj[k]);// 得到的是属性值}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用for in语句时，变量名常常使用 k 或者 key</p><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>用于获取对象自身所有的属性，效果类似 for … in。返回一个由属性名组成的新数组。</p><pre class="line-numbers language-none"><code class="language-none">var obj = {  name: 'PUJI',  age: 36}var arr = Object.keys(obj);console.log(arr); // ['name', 'age']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><p>视频教程：<a href="https://www.bilibili.com/video/BV17y4y1J7L1?p=49">https://www.bilibili.com/video/BV17y4y1J7L1?p=49</a></p><p>定义对象中新属性或修改原有的属性。</p><pre class="line-numbers language-none"><code class="language-none">Object.defineProperty(obj, prop, descriptor);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>obj: 目标对象</li><li>prop: 需定义或修改的属性名称</li><li>descriptor: 目标属性所拥有的特性。<ul><li>value ( 设置属性值，默认为 undefined )</li><li>writeable ( 值是否可重写，true / false 默认为 false )</li><li>enumerable ( 目标属性是否可以被枚举（遍历），true / false 默认为 false )</li><li>configurable ( 目标属性是否可以被删除或再次修改 descriptor 里的特性，true / false 默认为 false )</li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">var obj = {  uname: 'PUJI',  age: 36}Object.defineProperty(obj, 'sex', {  value: 'male'});console.log(obj);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用此函数，如果以前的对象中有新增的这个属性名则进行修改，如果没有则添加</li></ul><h2 id="面向对象-ES6"><a href="#面向对象-ES6" class="headerlink" title="面向对象 (ES6)"></a>面向对象 (ES6)</h2><ul><li>能够说出什么事面向对象</li><li>能够说出类和对象的关系</li><li>能够使用 class 创建自定义类</li><li>能够说出什么是继承</li></ul><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><h5 id="编程的两大思想："><a href="#编程的两大思想：" class="headerlink" title="编程的两大思想："></a>编程的两大思想：</h5><ul><li>面向过程 POP：Process-oriented programming，就是分析出解决问题所需要的步骤，然后再用函数把这些步骤一步步实现，使用的时候再一个一个的依次调用即可；</li><li>面向对象 OOP：Object Oriented Programming，就是把事物分解成一个个对象，然后由对象之间分工与合作。面向对象就是以对象功能来划分问题，而不是步骤。面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作或复杂的大型软件项目。</li></ul><h5 id="面向过程与面向对象的对比"><a href="#面向过程与面向对象的对比" class="headerlink" title="面向过程与面向对象的对比"></a>面向过程与面向对象的对比</h5><ul><li>面向过程性能比面向对象高，适合跟硬件联系很紧密的东西，但没有面向对象易维护、易复用、易扩展。</li></ul><h5 id="面向对象的特性："><a href="#面向对象的特性：" class="headerlink" title="面向对象的特性："></a>面向对象的特性：</h5><ul><li>封装性</li><li>继承性</li><li>多态性</li></ul><h5 id="面向对象的思维特点"><a href="#面向对象的思维特点" class="headerlink" title="面向对象的思维特点"></a>面向对象的思维特点</h5><p>面向对象更贴近我们的实际生活，可以使用面向对象描述现实世界的事物，但是事物分为抽象的事物和具体的事物</p><ul><li>抽取对象共同的属性和行为封装成一个类（模版）；</li><li>对类进行实例化，获取类的对象。</li></ul><p>在 javascript 中，对象是一组无须的相关属性和方法的集合，所有的事物都是对象，如字符串、数值、数组、函数等。对象由属性和方法组成。</p><h3 id="类-class"><a href="#类-class" class="headerlink" title="类 class"></a>类 class</h3><p>在 ES6 中新增加了类的概念，可以使用 class 关键词声明一个类，之后以这个类来实例化对象。类抽象了对象的公共部分，泛指某一大类，对象特指通过实例化出的一个具体对象</p><h4 id="书写语法"><a href="#书写语法" class="headerlink" title="书写语法"></a>书写语法</h4><pre class="line-numbers language-none"><code class="language-none">class Name {  ...}var a = new Name()；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="类-constructor-构造函数"><a href="#类-constructor-构造函数" class="headerlink" title="类 constructor 构造函数"></a>类 constructor 构造函数</h3><p>constructor() 方法是类的构造函数（默认方法），用于传递参数，返回实例对象，<strong>通过 new 命令生成对象实例时，自动调用该方法</strong>，如果没有定义，类内部会自动给我们创建一个 constructor()</p><p>对象原型 ( <strong>proto</strong> ) 和构造函数原型对象 ( prototype )里都有一个构造函数 constructor，因为他指回构造函数本身，constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。</p><pre class="line-numbers language-none"><code class="language-none">class Star {  constructor(uname, age) {    this.uname = uname;    this.age = age;  }}var ldh = new Star('刘德华',18);var zxy = new Star('张学友',19);console.log(ldh);console.log(zxy);console.log(Star.prototype.constructor); //返回原来的构造函数console.log(ldh.__proto__.constructor);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>通过 class 关键字创建类，类名首字母大写；</li><li>类里有个 constructor 函数，可以接受传递过来的参数，同时返回实例对象；</li><li>constructor 函数只要 new 生成实例时，就会自动调用这个函数，如果不写这个函数，类也会自动生成；</li><li>生成实例 new 不能省略；</li><li>创建类类名后面不要小括号，生成实例类名后面加小括号，构造函数不需要加 function</li></ul><h3 id="类中添加方法"><a href="#类中添加方法" class="headerlink" title="类中添加方法"></a>类中添加方法</h3><pre class="line-numbers language-none"><code class="language-none">window.addEventListener('load', function() {    class Star {        constructor(uname, age) {            this.uname = uname;            this.age = age;        }        sing(song) {            console.log(this.uname + song);        }    }    var ldh = new Star('刘德华',18);    var zxy = new Star('张学友',19);    ldh.sing('冰雨');    zxy.sing('李香兰');}); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>类里的所有函数不需要写 function；</li><li>多个函数方法之间不需要添加逗号分隔；</li></ul><h3 id="extends-类的继承"><a href="#extends-类的继承" class="headerlink" title="extends 类的继承"></a>extends 类的继承</h3><p>可以继承父类的属性与方法</p><pre class="line-numbers language-none"><code class="language-none">class A {  constructor() {    this.name = 'PUJI';  }}class B extends A {}var son = new B();console.log(son);  // {name: PUJI}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就先执行子类</li><li>如果子类没有，就去查找父类有没有这个方法，如果有就执行（就近原则）</li></ul><h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h3><p>super 关键字用于访问和调用对象父类上的函数，可以调用父类的构造函数，也可以调用父类的普通函数。</p><pre class="line-numbers language-none"><code class="language-none">// 调用父类的构造函数class A {  constructor(x,y) {    this.x = x;    this.y = y;  }  sum() {    console.log(this.x + this.y);  }}class B extends A {  constructor(x,y) {    super(x,y); // 调用了父类中的构造函数  }}var son = new B(1,2);son.sum();// 调用父类的普通函数class A {  say() {    return 'PUJI Design';  }}class B extends A {  say() {    console.log( super.say() + ' * Digital * Branding * Coding');  }}var son = new B();son.say();// 子类可以继承父类的方法也可以扩展自己的方法class A {  constructor(x, y) {    this.x = x;    this.y = y;  }  sum() {    console.log(this.x + this.y);  }}class B extends A {  constructor(x, y) {    super(x,y);    this.x = x;    this.y = y;  }  substract() {    console.log(this.x - this.y);  }}var son = new B(6,3);son.sum();son.substract();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当子类有自己的 this 时，super 必须在子类 this 之前调用</li></ul><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ol><li>在 ES6 中，类没有进行变量提升，所以必须先定义类，才能通过 new 实例化对象</li><li>类里有公用的属性和方法，一定要加 this 使用</li><li>constructor 里的this指向的是创建的实例对象</li></ol><h2 id="正则表达式-Regular-Expression"><a href="#正则表达式-Regular-Expression" class="headerlink" title="正则表达式 (Regular Expression)"></a>正则表达式 (Regular Expression)</h2><p>视频教程：<a href="https://www.bilibili.com/video/BV17y4y1J7L1?p=76">https://www.bilibili.com/video/BV17y4y1J7L1?p=76</a></p><p>正则表达式在线测试工具：<a href="https://c.runoob.com/front-end/854">https://c.runoob.com/front-end/854</a></p><p>目标：</p><ul><li>能够说出正则表达式的作用；</li><li>能够写出简单的正则表达式；</li><li>能够使用正则表达式对表单进行验证；</li><li>能够使用正则表达式替换内容。</li></ul><p>正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象。</p><h3 id="正则表达式的用途"><a href="#正则表达式的用途" class="headerlink" title="正则表达式的用途"></a>正则表达式的用途</h3><p>正则表达式通常被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名表单只能输入英文字母、数字或者下划线，昵称输入框中可以输入中文<strong>（匹配）</strong>。此外，正则表达式还常用于过滤掉页面内容中的一些敏感词<strong>（替换）</strong>，或从字符串中获取我们想要的特定部分<strong>（提取）</strong>等。</p><ul><li>正则表达式具有灵活性、逻辑性和功能性非常强；</li><li>可以迅速地用极简单的方式达到字符串的复杂控制；</li><li>在实际开发，一般都是直接复制写好的正则表达式，但是要求会使用正则表达式并且根据实际情况修改正则表达式。</li></ul><h3 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h3><p>在 JavaScript 中，可以通过两种方式创建正则表达式。</p><pre class="line-numbers language-none"><code class="language-none">// 通过调用 RegExp 对象的构造函数创建var 变量名 = new RegExp(/表达式/);var regexp = new RegExp(/123/);// 通过字面量创建 (更常用)var 变量名 = /表达式/;var regexp = /123/;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>正则表达式里的内容不需要加引号，不管是数字型还是字符串型</li></ul><h3 id="测试正则表达式"><a href="#测试正则表达式" class="headerlink" title="测试正则表达式"></a>测试正则表达式</h3><p>test() 正则表达式对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false，其参数是测试字符串。</p><pre class="line-numbers language-none"><code class="language-none">regexObj.test(str);// 示例var rg = /abc/;console.log(rg.test('abc')); // trueconsole.log(rg.test('abcd')); // trueconsole.log(rg.test('aabcd')); // true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>regexObj 是写的正则表达式</li><li>str 需要测试的文本</li><li>test 中的字符串需要引号</li><li>文字中只要其中一部分匹配表达式里的文字，就返回 true</li></ul><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>一个正则表达式可以由简单的字符构成，比如 /abc/，也可以是简单和特殊字符的组合，如 /ab*c/。其中特殊字符也被称为元字符，在正则表达式中是最具特殊意义的专用字符。</p><p>更多字符参考链接<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions</a></p><h5 id="边界符"><a href="#边界符" class="headerlink" title="边界符"></a>边界符</h5><table><thead><tr><th>边界符</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>表示匹配行首的文本（以谁开始）</td></tr><tr><td>$</td><td>表示匹配行尾的文本（以谁结束）</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">// 以 abc 开头的字符var rg = /^abc/;console.log(rg.test('abc')); // trueconsole.log(rg.test('abcd')); // trueconsole.log(rg.test('aabcd')); // false// 以 abc 结尾的字符var rg = /abc$/;console.log(rg.test('abc')); // trueconsole.log(rg.test('abcaaabc')); // trueconsole.log(rg.test('aabcd')); // false// 精确匹配，必须是 abc 字符串var rg = /^abc$/;console.log(rg.test('abc')); // trueconsole.log(rg.test('abcabc')); // falseconsole.log(rg.test('aabcd')); // false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h5><p>使用 [] 表示有一系列字符可供选择，只要匹配其中一个就可以</p><pre class="line-numbers language-none"><code class="language-none">// 只要包含有 a 或者有 b 或者有 c 都返回 truevar rg = /[abc]/;console.log(rg.test('ikaie')); // trueconsole.log(rg.test('bcoej')); // trueconsole.log(rg.test('eiowloo')); // false// 只有是 a / b / c 这三个字母才返回 truevar rg = /^[abc]$/;console.log(rg.test('a')); // trueconsole.log(rg.test('b')); // trueconsole.log(rg.test('d')); // false// 只要是单个英文小写字母都返回 true '-' 表示一个范围var rg = /^[a-z]$/;console.log(rg.test('a')); // trueconsole.log(rg.test('f')); // trueconsole.log(rg.test('B')); // false// 只要是单个英文字母(含大小写)或数字或_或-都返回 truevar rg = /^[a-zA-Z0-9_-]$/;console.log(rg.test('a')); // trueconsole.log(rg.test('D')); // trueconsole.log(rg.test('code')); // falseconsole.log(rg.test('6')); // true// 中括号内有^ 表示取反，不能包含里面的内容var rg = /^[^a-zA-Z0-9_-]$/;console.log(rg.test('a')); // falseconsole.log(rg.test('D')); // falseconsole.log(rg.test('code')); // falseconsole.log(rg.test('*')); // true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="量词符"><a href="#量词符" class="headerlink" title="量词符"></a>量词符</h5><p>用于设定某个模式出现的次数</p><table><thead><tr><th>量词</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>重复零次或更多次</td></tr><tr><td>+</td><td>重复一次或更多次</td></tr><tr><td>?</td><td>重复零次或一次</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或更多次</td></tr><tr><td>{n,m}</td><td>重复n到m次</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">// 重复0次或以上var rg = /^a*$/;console.log(rg.test('')); // trueconsole.log(rg.test('aaa')); // trueconsole.log(rg.test('aaabaaa')); // false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="括号的使用"><a href="#括号的使用" class="headerlink" title="括号的使用"></a>括号的使用</h3><p>方括号 [] 表示字符集合，匹配方括号中的任意字符</p><pre class="line-numbers language-none"><code class="language-none">var rg = /[abc]/; // 只要包含有 a / b / c 任意一个<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>花括号 {} 为量词符，表示重复次数</p><pre class="line-numbers language-none"><code class="language-none">rg = /^abc{3}$/; // 只是让花括号前面一个字符重复三次 abccc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>圆括号 () 表示优先级</p><pre class="line-numbers language-none"><code class="language-none">rg = /^(abc){3}$/; // 让 abc 重复三次 abcabcabc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>| 表示或</p><h3 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h3><p>预定义类指某些常见的模式的简写形式</p><table><thead><tr><th>预定义类</th><th>说明</th></tr></thead><tbody><tr><td>\d</td><td>匹配0-9之间的任一数字，相当于[0-9]</td></tr><tr><td>\D</td><td>匹配所有0-9以外的字符，相当于[^0-9]</td></tr><tr><td>\w</td><td>匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]</td></tr><tr><td>\W</td><td>除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]</td></tr><tr><td>\s</td><td>匹配空格(包含换行符、制表符、空格符等)，相当于[\t\r\n\v\f]</td></tr><tr><td>\S</td><td>匹配非空格的字符，相当于[^\t\r\n\v\f]</td></tr></tbody></table><h3 id="正则表达式参数"><a href="#正则表达式参数" class="headerlink" title="正则表达式参数"></a>正则表达式参数</h3><pre class="line-numbers language-none"><code class="language-none">/表达式/[switch];/激情|刺激/g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>switch 也称为修饰符，按照什么样的模式来匹配，有三种值</p><ul><li>g: 全局匹配，表示可获取整段文字中所有符合的内容。</li><li>i: 忽略大小写</li><li>gi: 全局匹配 + 忽略大小写</li></ul><h3 id="replace-替换"><a href="#replace-替换" class="headerlink" title="replace() 替换"></a>replace() 替换</h3><p>replace() 方法可以实现替换字符串操作，用来替换的参数可以是一个字符或事一个正则表达式</p><pre class="line-numbers language-none"><code class="language-none">stringObject.replace(regexp/substr, replacement)// 替换字符串var str = 'PUJI Design';var newStr = str.replace('Design', 'Lab');console.log(newStr); // PUJI Lab// 正则表达式// 替换字符串var str = 'PUJI Design';var newStr = str.replace(/Design/gi, 'Lab');console.log(newStr); // PUJI Lab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p>目标</p><ul><li>能够说出什么是内置对象</li><li>能够根据文档查询指定API的使用方法</li><li>能够使用 Math 对象的常用方法</li><li>能够使用 Date 对象的常用方法</li><li>能够使用 Array 对象的常用方法</li><li>能够使用 String 对象的常用方法</li></ul><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>内置对象就是 JavaScript 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能（属性和方法）。常用的内置对象包含 Math, Date, Array, String等</p><p>查阅文档</p><p>可以通过 MDN / W3C 来查询，Mozilla 开发者网络（MDN） 提供了有关开放网络技术 （Open Web）的信息，包括 HTML、CSS和万维网及HTML5应用的API。</p><p><a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></p><h3 id="Math-数学对象"><a href="#Math-数学对象" class="headerlink" title="Math 数学对象"></a>Math 数学对象</h3><p>Math 是一个内置对象，它拥有一些数学常数属性和数学函数方法。Math 不是一个函数对象。</p><p>封装自己的数学对象</p><pre class="line-numbers language-none"><code class="language-none">var myMath = {    PI: 3.1415926,    max: function() {        var max = arguments[0];        for (i = 1; i &lt; arguments.length; i++) {            if (arguments[i] &gt; max) {                max = arguments[i];            }        }        return max;    },    min: function() {        var min = arguments[0];        for (i = 1; i &lt; arguments.length; i++) {            if (arguments[i] &lt; min) {                min = arguments[i];            }        }        return min;    }}console.log(myMath.PI);console.log(myMath.max(1, 6, 9, 36, -15));console.log(myMath.min(1, 6, 9, 36, -15));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="日期对象"><a href="#日期对象" class="headerlink" title="日期对象"></a>日期对象</h3><p>是一个构造函数，使用new来调用创建我们的日期对象</p><pre class="line-numbers language-none"><code class="language-none">var date = new Date();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用Date如果没有参数，返回当前系统的当前时间</li><li>参数常用写法，数字型 2022, 03, 03 或者是字符串型 ‘2022-03-03 12:36:18’</li></ul><pre class="line-numbers language-none"><code class="language-none">var date = new Date('2022-03-03 12:36:18');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="扩展内置对象"><a href="#扩展内置对象" class="headerlink" title="扩展内置对象"></a>扩展内置对象</h4><p>视频教程：<a href="https://www.bilibili.com/video/BV17y4y1J7L1?p=33&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV17y4y1J7L1?p=33&amp;spm_id_from=pageDriver</a></p><p>可以通过原型对象，对原来的内置对象进行扩展自定义的方法，比如给数组增加自定义求偶数和的功能。</p><h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><p>在 JavaScript 上提供了三个特殊的引用类型，分别是 String / Number / Boolean。把简单数据类型包装为复杂数据类型就是基本包装类型，这样基本数据类型就有了属性和方法。</p><pre class="line-numbers language-none"><code class="language-none">// 示例var str = 'PUJI';console.log(str.length);// js的处理过程var temp = new String('PUJI'); // 新建一个对象str = temp; // 把临时变量的值赋予 strtemp = null; //销毁临时变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="预解析（重要）"><a href="#预解析（重要）" class="headerlink" title="预解析（重要）"></a>预解析（重要）</h2><p>目标</p><ul><li>能够知道解析器运行js分为哪两步</li><li>能够说出变量提升的步骤和运行过程</li><li>能够说出函数提升的步走和运行过程</li></ul><h3 id="什么是预解析"><a href="#什么是预解析" class="headerlink" title="什么是预解析"></a>什么是预解析</h3><pre class="line-numbers language-none"><code class="language-none">// 示例1console.log(num); // undefinedvar num = 10;// 示例2 (成功调用)fn();function fn() {  console.log(1);}// 示例3 (报错)fn();var fun = function() {  console.log(1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两步：预解析和代码执行。</p><ol><li>预解析：JavaScript 引擎会把 js 里所有的 var 还有 function 提升到当前作用域的最前面</li><li>预解析分为变量预解析（变量提升）和函数预解析（函数提升）</li><li>变量提升，就是把所有的变量声明提升到当前的作用与前面，不提升赋值。</li><li>函数提升，就是把所有的函数声明与函数体提升到当前作用域的前面，但不做调用。</li><li>代码执行：按照代码书写的顺序从上往下执行</li></ol><p>按照预解析的过程来分析，我们可以把上面的代码的流程按照解析过程来进行顺序分析，相当于代码按照以下顺序进行执行</p><pre class="line-numbers language-none"><code class="language-none">// 示例1 (由于在执行语句前只声明了变量，但没赋值)var num;console.log(num); // undefinednum = 10;// 示例2 (成功调用)function fn() {  console.log(1);}fn();// 示例3 (报错)var fun； (由于在调用语句前只声明了变量，但没赋值，fn属于变量而非函数)fn();fun = function() {  console.log(1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="严格模式-Strict-mode"><a href="#严格模式-Strict-mode" class="headerlink" title="严格模式 (Strict mode)"></a>严格模式 (Strict mode)</h2><p>JavaScript 除了提供正常模式外，还提供了严格模式。ES5 的严格模式是采用具有限制性 JavaScript 变体的一种方式，即在严格的条件下运行 JS 代码。</p><ul><li>严格模式对正常的 JavaScript 语法的一些不合理、不严谨之处，减少了一些怪异行为；</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译效率，增加运行速度；</li><li>禁用了在 ECMAScript 的未来版本中可能会定义的一些语法不可用于变量名。</li></ul><h3 id="开启严格模式"><a href="#开启严格模式" class="headerlink" title="开启严格模式"></a>开启严格模式</h3><p>视频教程：<a href="https://www.bilibili.com/video/BV17y4y1J7L1?p=59">https://www.bilibili.com/video/BV17y4y1J7L1?p=59</a><br>更多规则参考链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode</a></p><p>严格模式可以应用到整个脚本或个别函数中，因此在使用时，我们可以将严格模式分为<strong>为脚本开启严格模式</strong>和<strong>为函数开启严格模式</strong>两种情况。</p><h4 id="为脚本开启严格模式"><a href="#为脚本开启严格模式" class="headerlink" title="为脚本开启严格模式"></a>为脚本开启严格模式</h4><p>为整个脚本文件开启严格模式，只需在所有语句之前放一个特定语句 “use strict” 或 ‘use strict’。</p><pre class="line-numbers language-none"><code class="language-none">// 开启严格模式'use strict';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="为函数开启严格模式"><a href="#为函数开启严格模式" class="headerlink" title="为函数开启严格模式"></a>为函数开启严格模式</h4><pre class="line-numbers language-none"><code class="language-none">function fn() {  'use strict';  ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="变量规定"><a href="#变量规定" class="headerlink" title="变量规定"></a>变量规定</h3><ul><li>变量必须先声明然后再使用；</li><li>严禁删除已经声明过的变量。</li></ul><h3 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h3><ul><li>全局作用域中定义的函数的 this 是 undefined 而不再是 window；</li><li>构造函数如果不加 new 进行调用，this 会报错，new 实例化的构造函数指向创建的对象实例；</li><li>定时器的 this 还是指向 window；</li><li>事件、对象里的 this 还是指向调用者。</li></ul><h3 id="函数变化"><a href="#函数变化" class="headerlink" title="函数变化"></a>函数变化</h3><ul><li>函数的形参名称不可重名；</li><li>函数声明必须在顶层，不允许在非函数的代码块内声明函数 (如括号内，if，for 等)。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端面试-Vue</title>
      <link href="/2022/06/26/qian-duan-mian-shi-vue-pian/"/>
      <url>/2022/06/26/qian-duan-mian-shi-vue-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-面试题"><a href="#Vue-面试题" class="headerlink" title="Vue 面试题"></a>Vue 面试题</h1><h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><h3 id="react-和-vue-有什么区别？"><a href="#react-和-vue-有什么区别？" class="headerlink" title="react 和 vue 有什么区别？"></a>react 和 vue 有什么区别？</h3><p>React 是由Facebook创建的JavaScript UI框架，React推广了 Virtual DOM( 虚拟 DOM )并创造了 JSX 语法。JSX 语法的出现允许我们在 javascript 中书写 HTML 代码。</p><p>VUE 是由尤雨溪开发的，VUE 使用了模板系统而不是JSX，因其实模板系统都是用的普通的 HTML，所以对应用的升级更方便、更容易，而不需要整体重构。</p><p>VUE 相较于 React 更容易上手，如果是一个有一定开发经验的开发者，甚至都不需要花额外的时间去学习，直接一遍开发一遍查文挡即可。</p><h4 id="VUE-与-React-区别"><a href="#VUE-与-React-区别" class="headerlink" title="VUE 与 React 区别"></a>VUE 与 React 区别</h4><p>React 的思路是 HTML in JavaScript 也可以说是 All in JavaScript，通过 JavaScript 来生成 HTML，所以设计了 JSX 语法，还有通过 JS 来操作 CSS，社区的styled-component、JSS等。</p><p>Vue 是把 HTML，CSS，JavaScript 组合到一起，用各自的处理方式，Vue 有单文件组件，可以把 HTML、CSS、JS 写到一个文件中，HTML 提供了模板引擎来处理。</p><p>React 整体是函数式的思想，在 React 中是单向数据流，推崇结合 immutable 来实现数据不可变。</p><p>而 Vue 的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立 Watcher 来监听，当属性变化的时候，响应式的更新对应的虚拟 DOM。</p><p>如上，所以 React 的性能优化需要手动去做，而Vue的性能优化是自动的，但是Vue的响应式机制也有问题，就是当 state 特别多的时候，Watcher 会很多，会导致卡顿。</p><h4 id="React-与-VUE-共同点"><a href="#React-与-VUE-共同点" class="headerlink" title="React 与 VUE 共同点"></a>React 与 VUE 共同点</h4><p>React 与 Vue 存在很多共同点，例如他们都是 JavaScript 的 UI 框架，专注于创造前端的富应用。不同于早期的 JavaScript 框架“功能齐全”，Reat 与 Vue 只有框架的骨架，其他的功能如路由、状态管理等是框架分离的组件。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><hr><p><strong>React</strong></p><ul><li>灵活性和响应性：它提供最大的灵活性和响应能力。</li><li>丰富的JavaScript库：来自世界各地的贡献者正在努力添加更多功能。</li><li>可扩展性：由于其灵活的结构和可扩展性，React已被证明对大型应用程序更好。</li><li>不断发展： React得到了Facebook专业开发人员的支持，他们不断寻找改进方法。</li><li>Web或移动平台： React提供React Native平台，可通过相同的React组件模型为iOS和Android开发本机呈现的应用程序。</li></ul><p><strong>Vue</strong></p><ul><li>易于使用： Vue.js包含基于HTML的标准模板，可以更轻松地使用和修改现有应用程序。</li><li>更顺畅的集成：无论是单页应用程序还是复杂的Web界面，Vue.js都可以更平滑地集成更小的部件，而不会对整个系统产生任何影响。</li><li>更好的性能，更小的尺寸：它占用更少的空间，并且往往比其他框架提供更好的性能。</li><li>精心编写的文档：通过详细的文档提供简单的学习曲线，无需额外的知识; HTML和JavaScript将完成工- 作。</li><li>适应性：整体声音设计和架构使其成为一种流行的JavaScript框架。</li><li>它提供无障碍的迁移，简单有效的结构和可重用的模板。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>如上所说的 Vue 的响应式机制也有问题，当 state 特别多的时候，Watcher 会很多，会导致卡顿，所以大型应用（状态特别多的）一般用 React，更加可控。</p><p>可对于易用性来说，VUE 是更容易上手的，对于项目来说新人更容易接手。</p><p>使用 React 的公司：Facebook，Instagram，Netflix，纽约时报，雅虎，WhatsApp，Codecademy，Dropbox，Airbnb，Asana，微软等。</p><p>使用 Vue 的公司：Facebook，Netflix，Adobe，Grammarly，Behance，小米，阿里巴巴，Codeship，Gitlab和Laracasts等。</p><p>所以，技术没有哪个更好或者是更优秀，只要适合自己的才是最合适的。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试-JavaScript篇</title>
      <link href="/2022/06/25/qian-duan-mian-shi-javascript-pian/"/>
      <url>/2022/06/25/qian-duan-mian-shi-javascript-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript面试题"><a href="#JavaScript面试题" class="headerlink" title="JavaScript面试题"></a>JavaScript面试题</h1><h2 id="JavaScript基础语法"><a href="#JavaScript基础语法" class="headerlink" title="JavaScript基础语法"></a>JavaScript基础语法</h2><h3 id="null-和-undefined-有什么区别？"><a href="#null-和-undefined-有什么区别？" class="headerlink" title="null 和 undefined 有什么区别？"></a>null 和 undefined 有什么区别？</h3><p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</p><p>undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。</p><p>undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</p><p>当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p><h2 id="JavaScript进阶webAPI"><a href="#JavaScript进阶webAPI" class="headerlink" title="JavaScript进阶webAPI"></a>JavaScript进阶webAPI</h2><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript，ES6 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试-html，css篇</title>
      <link href="/2022/06/24/qian-duan-mian-shi-html-css-pian/"/>
      <url>/2022/06/24/qian-duan-mian-shi-html-css-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="html，css面试题"><a href="#html，css面试题" class="headerlink" title="html，css面试题"></a>html，css面试题</h1><h2 id="html篇"><a href="#html篇" class="headerlink" title="html篇"></a>html篇</h2><h3 id="简述html页面渲染过程"><a href="#简述html页面渲染过程" class="headerlink" title="简述html页面渲染过程"></a>简述html页面渲染过程</h3><p>  整个渲染过程其实就是将URL对应的各种资源，通过浏览器渲染引擎的解析，输出可视化的图像。</p><p><strong>基本概念</strong></p><ul><li>HTML解释器：解释HTML语言的解释器，本质是将HTML文本解释成DOM树（文档对象模型）。</li><li>CSS解释器：解释样式表的解释器，其作用是将DOM中的各个元素对象加上样式信息，从而为计算最后结果的布局提供依据。</li><li>布局：将DOM和css样式信息结合起来，计算它们的大小位置等布局信息，形成一个能够表示这所有信息的内部表示模型即渲染树。</li><li>JavaScript引擎：JavaScript可以修改网页的内容，也能修改CSS的信息，JavaScript引擎解释JavaScript代码并把代码的逻辑和对DOM和CSS的改动信息应用到布局中去，从而改变渲染的结果。</li></ul><p><strong>基本过程</strong></p><ul><li>1.解析HTML文件，创建DOM树<br>浏览器解析html源码，然后创建一个 DOM树。并行请求 css/image/js在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。DOM树的根节点就是 documentElement，对应的是html标签。</li><li>2.解析CSS,形成CSS对象模型<br>浏览器解析CSS代码，计算出最终的样式数据。构建CSSOM树。对CSS代码中非法的语法它会直接忽略掉。解析CSS的时候会按照如下顺序来定义优先级：</li></ul><p>浏览器默认设置 &lt; 用户设置 &lt; 外链样式 &lt; 内联样式 &lt; html中的style。</p><ul><li>3.将CSS与DOM合并，构建渲染树（renderingtree）<br>DOM Tree + CSSOM –&gt; 渲染树（rendering tree）。渲染树和DOM树有点像，但是是有区别的。DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的css属性。</li><li>4.布局和绘制<br>一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。</li></ul><p>以上四个步骤并不是一次性顺序完成的。如果DOM或者CSSOM被修改，以上过程会被重复执行。实际上，CSS和JavaScript往往会多次修改DOM或者CSSOM。</p><p><strong>Repaint(重绘)</strong><br>重绘是改变不影响元素在网页中的位置的元素样式时，譬如background-color(背景色)， border-color(边框色)，visibility(可见性)，浏览器会根据元素的新属性重新绘制一次(这就是重绘，或者说重新构造样式)，使元素呈现新的外观。</p><p>重绘不会带来重新布局，所以并不一定伴随重排。</p><p><strong>Reflow（重排）</strong><br>渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。</p><p>“重绘”不一定需要”重排”，比如改变某个网页元素的颜色，就只会触发”重绘”，不会触发”重排”，因为布局没有改变。</p><p>但是，”重排”必然导致”重绘”，比如改变一个网页元素的位置，就会同时触发”重排”和”重绘”，因为布局改变了。</p><hr><h3 id="页面导入样式时，使用link和-import有什么区别？"><a href="#页面导入样式时，使用link和-import有什么区别？" class="headerlink" title="页面导入样式时，使用link和@import有什么区别？"></a>页面导入样式时，使用link和@import有什么区别？</h3><p>link属于HTML标签，而@import是css提供的；</p><p>页面被加载时，link会同时被加载，而@import引用的css会等到页面被加载完再加载；</p><p>@import只在IE5以上才能识别，而link是XHTML标签，无兼容问题；</p><p>link方式的样式的权重高于@import的权重。</p><hr><h3 id="HTML5有哪些新特性？"><a href="#HTML5有哪些新特性？" class="headerlink" title="HTML5有哪些新特性？"></a>HTML5有哪些新特性？</h3><ul><li>新增语义化标签：nav、header、footer、aside、section、article</li><li>音频、视频标签：audio、video</li><li>数据存储：localStorage、sessionStorage</li><li>canvas（画布）、Geolocation（地理定位）、websocket（通信协议）</li><li>input标签新增属性：placeholder、autocomplete、autofocus、required</li><li>history API<br>  go、forward、back、pushstate</li></ul><hr><h3 id="行内元素有哪些？块级元素有哪些？-空-void-元素有那些？"><a href="#行内元素有哪些？块级元素有哪些？-空-void-元素有那些？" class="headerlink" title="行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？"></a>行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h3><p>CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。</p><ul><li><p>常见的块元素有：<br><code>&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt;</code></p></li><li><p>常用的内联元素有：<br><code>&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt;</code></p></li><li><p>常用的内联块状元素有：<br><code>&lt;img&gt;、&lt;input&gt;</code></p></li><li><p>知名的空元素：<br><code>&lt;br/&gt; &lt;hr/&gt; &lt;img/&gt; &lt;input/&gt; &lt;link/&gt; &lt;meta/&gt; &lt;br /&gt;</code></p></li></ul><hr><h3 id="如何禁用a标签跳转页面或定位链接"><a href="#如何禁用a标签跳转页面或定位链接" class="headerlink" title="如何禁用a标签跳转页面或定位链接?"></a>如何禁用a标签跳转页面或定位链接?</h3><p>当页面中a标签不需要任何跳转时，从原理上来讲，可分如下两种方法：</p><ul><li><p>标签属性href，使其指向空或不返回任何内容。如：</p><pre class="line-numbers language-none"><code class="language-none">&lt;a href="javascript:void(0);" &gt;点此无反应javascript:void(0)&lt;/a&gt;&lt;a href="javascript:;" &gt;点此无反应javascript:&lt;/a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>从标签事件入手，阻止其默认行为。如：<br>html方法：</p><pre class="line-numbers language-none"><code class="language-none">&lt;a href="" onclick="return false;"&gt;return false;&lt;/a&gt;&lt;a href="#" onclick="return false;"&gt;return false;&lt;/a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者在js文件中阻止默认点击事件：<br><code>Event.preventDefault()</code><br>还可以在css文件中处理点击，不响应任何鼠标事件：<br><code>pointer-events: none;</code></p></li></ul><h2 id="css篇"><a href="#css篇" class="headerlink" title="css篇"></a>css篇</h2><h3 id="html和css中的图片加载与渲染规则是什么样的？"><a href="#html和css中的图片加载与渲染规则是什么样的？" class="headerlink" title="html和css中的图片加载与渲染规则是什么样的？"></a>html和css中的图片加载与渲染规则是什么样的？</h3><p>Web浏览器先会把获取到的HTML代码解析成一个DOM树，HTML中的每个标签都是DOM树中的一个节点，包括display: none隐藏的标签，还有JavaScript动态添加的元素等。浏览器会获取到所有样式，并会把所有样式解析成样式规则，在解析的过程中会去掉浏览器不能识别的样式。</p><p>浏览器将会把DOM树和样式规则组合在一起（DOM元素和样式规则匹配）后将会合建一个渲染树（Render Tree），渲染树类似于DOM树，但两者别还是很大的：渲染树能识别样式，渲染树中每个节点（NODE）都有自己的样式，而且渲染树不包含隐藏的节点（比如display:none的节点，还有/head&gt;内的一些节点），因为这些节点不会用于渲染，也不会影响节点的渲染，因此不会包含到渲染树中。一旦渲染树构建完毕后，浏览器就可以根据渲染树来绘制页面了。</p><p>简单的归纳就是浏览器渲染Web页面大约会经过六个过程：</p><ul><li>解析HTML，构成DOM树</li><li>解析加载的样式，构建样式规则树</li><li>加载JavaScript，执行JavaScript代码</li><li>DOM树和样式规则树进行匹配，构成渲染树</li><li>计算元素位置进行页面布局</li><li>绘制页面，最终在浏览器中呈现</li></ul><p>是不是会感觉这个和我们图像加载渲染没啥关系一样，事实并非如此，因为img、picture或者background-image都是DOM树或样式规则中的一部分，那么咱们套用进来，图片加载和渲染的时机有可能是下面这样：</p><ul><li>解析HTML时，如果遇到img或picture标签，将会加载图片</li><li>解析加载的样式，遇到background-image时，并不会加载图片，而会构建样式规则树</li><li>加载JavaScript，执行JavaScript代码，如果代码中有创建img元素之类，会添加到DOM树中；如查有`添加background-image规则，将会添加到样式规则树中</li><li>DOM树和样式规则匹配时构建渲染树，如果DOM树节点匹配到样式规则中的backgorund-image，则会加载背景图片</li><li>计算元素（图片）位置进行布局</li><li>开始渲染图片，浏览器将呈现渲染出来的图片</li></ul><p>上面套用浏览器渲染页面的机制，但图片加载与渲染还是有一定的规则。因为，页面中不是所有的img&gt;（或picture）元素引入的图片和background-image引入的背景图片都会加载的。那么就引发出新问题了，什么时候会真正的加载，加载规则又是什么？</p><p>先概括一点：</p><blockquote><p>Web页面中不是所有的图片都会加载和渲染！</p></blockquote><p>根据前面介绍的浏览器加载和渲染机制，我们可以归纳为：</p><ul><li>img&gt;、picture&gt;和设置background-image的元素遇到display:none时，图片会加载但不会渲染</li><li>img&gt;、picture&gt;和设置background-image的元素祖先元素设置display:none时，background-image不会渲染也不会加载，而img和picture引入的图片不会渲染但会加载</li><li>img&gt;、picture&gt;和background-image引入相同路径相同图片文件名时，图片只会加载一次</li><li>样式文件中background-image引入的图片，如果匹配不到DOM元素，图片不会加载</li><li>伪类引入的background-image，比如:hover，只有当伪类被触发时，图片才会加载</li></ul><hr><h3 id="css3新增了哪些特性？"><a href="#css3新增了哪些特性？" class="headerlink" title="css3新增了哪些特性？"></a>css3新增了哪些特性？</h3><p><img src="https://static.vue-js.com/d58f6df0-9b5e-11eb-ab90-d9ae814b240d.png"></p><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>css，即层叠样式表（Cascading Style Sheets）的简称，是一种标记语言，由浏览器解释执行用来使页面变得更美观</p><p>css3是css的最新标准，是向后兼容的，CSS1/2 的特性在 CSS3 里都是可以使用的</p><p>而 CSS3 也增加了很多新特性，为开发带来了更佳的开发体验</p><h4 id="二、选择器"><a href="#二、选择器" class="headerlink" title="二、选择器"></a>二、选择器</h4><p>css3中新增了一些选择器，主要为如下图所示:<br><img src="https://static.vue-js.com/e368cf20-9b5e-11eb-85f6-6fac77c0c9b3.png"></p><h4 id="三、新样式"><a href="#三、新样式" class="headerlink" title="三、新样式"></a>三、新样式</h4><p><strong>边框</strong><br>css3新增了三个边框属性，分别是：</p><ul><li><p>border-radius：创建圆角边框</p></li><li><p>box-shadow：为元素添加阴影</p></li><li><p>border-image：使用图片来绘制边框</p></li></ul><p><strong>box-shadow</strong><br>设置元素阴影，设置属性如下：</p><ul><li>水平阴影</li><li>垂直阴影</li><li>模糊距离(虚实)</li><li>阴影尺寸(影子大小)</li><li>阴影颜色</li><li>内/外阴影<br>其中水平阴影和垂直阴影是必须设置的</li></ul><p><strong>背景</strong><br>新增了几个关于背景的属性，分别是background-clip、background-origin、background-size和background-break</p><p><strong>background-clip</strong><br>用于确定背景画区，有以下几种可能的属性：</p><ul><li>background-clip: border-box; 背景从border开始显示</li><li>background-clip: padding-box; 背景从padding开始显示</li><li>background-clip: content-box; 背景显content区域开始显示</li><li>background-clip: no-clip; 默认属性，等同于border-box<br>通常情况，背景都是覆盖整个元素的，利用这个属性可以设定背景颜色或图片的覆盖范围</li></ul><p><strong>background-origin</strong><br>当我们设置背景图片时，图片是会以左上角对齐，但是是以border的左上角对齐还是以padding的左上角或者content的左上角对齐? border-origin正是用来设置这个的</p><ul><li>background-origin: border-box; 从border开始计算background-position</li><li>background-origin: padding-box; 从padding开始计算background-position</li><li>background-origin: content-box; 从content开始计算background-position<br>默认情况是padding-box，即以padding的左上角为原点</li></ul><p><strong>background-size</strong><br>background-size属性常用来调整背景图片的大小，主要用于设定图片本身。有以下可能的属性：</p><ul><li>background-size: contain; 缩小图片以适合元素（维持像素长宽比）</li><li>background-size: cover; 扩展元素以填补元素（维持像素长宽比）</li><li>background-size: 100px 100px; 缩小图片至指定的大小</li><li>background-size: 50% 100%; 缩小图片至指定的大小，百分比是相对包 含元素的尺寸</li></ul><p><strong>background-break</strong><br>元素可以被分成几个独立的盒子（如使内联元素span跨越多行），background-break 属性用来控制背景怎样在这些不同的盒子中显示</p><ul><li>background-break: continuous; 默认值。忽略盒之间的距离（也就是像元素没有分成多个盒子，依然是一个整体一样）</li><li>background-break: bounding-box; 把盒之间的距离计算在内；</li><li>background-break: each-box; 为每个盒子单独重绘背景</li></ul><p><strong>文字</strong><br><strong>word-wrap</strong><br>语法：word-wrap: normal|break-word</p><ul><li>normal：使用浏览器默认的换行</li><li>break-all：允许在单词内换行</li></ul><p><strong>text-overflow</strong><br>text-overflow设置或检索当当前行超过指定容器的边界时如何显示，属性有两个值选择：</p><ul><li>clip：修剪文本</li><li>ellipsis：显示省略符号来代表被修剪的文本</li></ul><p><strong>text-shadow</strong><br>text-shadow可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色</p><p><strong>text-decoration</strong><br>CSS3里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置：</p><ul><li><p>text-fill-color: 设置文字内部填充颜色</p></li><li><p>text-stroke-color: 设置文字边界填充颜色</p></li><li><p>text-stroke-width: 设置文字边界宽度</p></li></ul><p><strong>颜色</strong><br>css3新增了新的颜色表示方式rgba与hsla</p><ul><li>rgba分为两部分，rgb为颜色值，a为透明度</li><li>hala分为四部分，h为色相，s为饱和度，l为亮度，a为透明度</li></ul><h4 id="四、transition-过渡"><a href="#四、transition-过渡" class="headerlink" title="四、transition 过渡"></a>四、transition 过渡</h4><p>transition属性可以被指定为一个或多个CSS属性的过渡效果，多个属性之间用逗号进行分隔，必须规定两项内容：</p><ul><li>过度效果</li><li>持续时间<br>语法如下：<br><code>transition： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)</code><br>上面为简写模式，也可以分开写各个属性<pre class="line-numbers language-none"><code class="language-none">transition-property: width; transition-duration: 1s;transition-timing-function: linear;transition-delay: 2s;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="五、transform-转换"><a href="#五、transform-转换" class="headerlink" title="五、transform 转换"></a>五、transform 转换</h4><p>transform属性允许你旋转，缩放，倾斜或平移给定元素</p><p>transform-origin：转换元素的位置（围绕那个点进行转换），默认值为(x,y,z):(50%,50%,0)</p><p>使用方式：</p><ul><li>transform: translate(120px, 50%)：位移</li><li>transform: scale(2, 0.5)：缩放</li><li>transform: rotate(0.5turn)：旋转</li><li>transform: skew(30deg, 20deg)：倾斜</li></ul><h4 id="六、animation-动画"><a href="#六、animation-动画" class="headerlink" title="六、animation 动画"></a>六、animation 动画</h4><p>动画这个平常用的也很多，主要是做一个预设的动画。和一些页面交互的动画效果，结果和过渡应该一样，让页面不会那么生硬</p><p>animation也有很多的属性</p><ul><li>animation-name：动画名称</li><li>animation-duration：动画持续时间</li><li>animation-timing-function：动画时间函数</li><li>animation-delay：动画延迟时间</li><li>animation-iteration-count：动画执行次数，可以设置为一个整数，也可以设置为infinite，意思是无限循环</li><li>animation-direction：动画执行方向</li><li>animation-paly-state：动画播放状态</li><li>animation-fill-mode：动画填充模式</li></ul><h4 id="七、渐变"><a href="#七、渐变" class="headerlink" title="七、渐变"></a>七、渐变</h4><p>颜色渐变是指在两个颜色之间平稳的过渡，css3渐变包括</p><ul><li><p>linear-gradient：线性渐变</p><blockquote><p>background-image: linear-gradient(direction, color-stop1, color-stop2, …);</p></blockquote></li><li><p>radial-gradient：径向渐变</p><blockquote><p>linear-gradient(0deg, red, green);</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> html，css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora的用法</title>
      <link href="/2022/06/16/typora-de-yong-fa/"/>
      <url>/2022/06/16/typora-de-yong-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora的用法"><a href="#Typora的用法" class="headerlink" title="Typora的用法"></a>Typora的用法</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><span id="more"></span><ul><li>列表一</li><li>列表二<br>  a 子列表<br>  b 子列表</li><li>列表三</li></ul><p><a href="https://github.com/">我的github</a></p><p><img src="https://tse1-mm.cn.bing.net/th/id/R-C.f4a601bc90fa06c4e8d0179462db0eae?rik=tRjWlXCtAxy7gQ&amp;riu=http://img.crcz.com/allimg/201809/25/1537872713573183.jpg&amp;ehk=TFKk84fyQu7LuQKIbvBYkEufRYMDRhIulB42R66cVT4=&amp;risl=&amp;pid=ImgRaw&amp;r=0&amp;sres=1&amp;sresct=1" alt="King"></p><p><em>字体是斜线</em><br><strong>字体加粗</strong></p><hr><p>你好呀</p><hr><p><code>&lt;html&gt;单行代码&lt;/html&gt;</code></p><pre class="line-numbers language-none"><code class="language-none">&lt;html&gt;    &lt;head&gt;        &lt;title&gt;我是King&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;&lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>我的内容是引用的</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 使用方法 </tag>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/06/16/hello-world/"/>
      <url>/2022/06/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
