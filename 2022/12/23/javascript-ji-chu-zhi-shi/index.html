<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="javascript基础知识, 魔鬼">
    <meta name="description" content="JavaScript 基本语法手册概述JavaScript 简称 JS，是运行在客户端的脚本语言，浏览器通过 JavaScript 引擎来执行 JS 代码，JS 引擎执行代码时逐行解释每一句源码然后由计算机去执行，即读取一行就执行一行。
J">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    
    <style>
        body{
            background-image: url(https://pic1.zhimg.com/v2-a9f54a95f2a28b1c934d248681d66e42_720w.jpg?source=172ae18b);
            background-repeat:no-repeat;
            background-size: 100% 100%;
            background-attachment:fixed;
        }
    </style>


    <title>javascript基础知识 | 魔鬼</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">魔鬼</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">魔鬼</div>
        <div class="logo-desc">
            
            大概也许是因为热爱！
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/20.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">javascript基础知识</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/javascript/">
                                <span class="chip bg-color">javascript</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-12-23
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2022-12-23
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    21.2k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    83 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="JavaScript-基本语法手册"><a href="#JavaScript-基本语法手册" class="headerlink" title="JavaScript 基本语法手册"></a>JavaScript 基本语法手册</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JavaScript 简称 JS，是运行在客户端的脚本语言，浏览器通过 JavaScript 引擎来执行 JS 代码，JS 引擎执行代码时逐行解释每一句源码然后由计算机去执行，即读取一行就执行一行。</p>
<p>JavaScript 由三部分组成，ECMAScript ( JavaScript 语法 ), DOM (页面文档对象模型) , BOM ( 浏览器对象模型 )。</p>
<ul>
<li><strong>ECMAScript ( JavaScript ):</strong> 规定了 JS 的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套 JS 语法工业标准；</li>
<li><strong>DOM – 文档对象模型 ( Document Object Model ):</strong> 是 W3C 组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作 (大小、位置、颜色等)；</li>
<li><strong>BOM – 浏览器对象模型 ( Browser Object Model ):</strong> 它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过 BOM 可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。</li>
</ul>
<h2 id="如何引入-JavaScript"><a href="#如何引入-JavaScript" class="headerlink" title="如何引入 JavaScript"></a>如何引入 JavaScript</h2><p>JS 代码可以写在页面的任何位置，有三种不同的写法，为符合标准，建议将所有 JS 都写在外部文件。</p>
<pre class="line-numbers language-none"><code class="language-none">// 行内插入
&lt;input type="button" onclick="alert('a')"&gt;

// 页面内嵌
&lt;script&gt; ... &lt;/script&gt;

// 引入外部文件
&lt;script src="filename.js"&gt;&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>所有 JS 代码建议都使用单引号书写；</li>
<li>引用外部 JS 文件的 <script></script>， 标签内不可写代码。</li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><pre class="line-numbers language-none"><code class="language-none">// 单行注释 ， 快捷键 "ctrl + /" 或 "cmd + /"

/* 多行注释
 * 快捷键 shift + alt + a
 * 快捷键是 vscode 中的 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="js-的书写规范"><a href="#js-的书写规范" class="headerlink" title="js 的书写规范"></a>js 的书写规范</h2><h3 id="标识符命名规范与语法规范"><a href="#标识符命名规范与语法规范" class="headerlink" title="标识符命名规范与语法规范"></a>标识符命名规范与语法规范</h3><ul>
<li>变量、函数的名称必须要有意义</li>
<li>变量名称一般使用名次</li>
<li>函数名称一般使用动词</li>
</ul>
<h3 id="变量的命名规则"><a href="#变量的命名规则" class="headerlink" title="变量的命名规则"></a>变量的命名规则</h3><ul>
<li>必须以英文字母(包含大小写)、“_” 或 “$” 开头；</li>
<li>变量名可包含英文字母(包含大小写)、“_” 、 “$” 与数字, 如 usrAge, num01, _name, $age… ；</li>
<li>严格区分大小写，如 var = app; 和 var = App; 是两个变量；</li>
<li>不可用系统中有特殊语法含义的关键字或保留字作为变量名 (见下表)；</li>
<li>命名需有一定的含义，以方便查阅代码可更好的理解；</li>
<li>遵守驼峰命名法，首字母小写，后面单词的首字母大写，如 myFirstName。</li>
</ul>
<p><strong>关键字：</strong></p>
<p>break case catch continue default delete do else finally for function if in instanceof new return switch this throw try typeof var void while with</p>
<p><strong>保留字：</strong></p>
<p>abstract boolean byte char class const debugger double enum export extends final float goto implements import int interface long name native package private protected public short static super synchronized throws transient volatile</p>
<h3 id="操作符规范"><a href="#操作符规范" class="headerlink" title="操作符规范"></a>操作符规范</h3><ul>
<li>操作符的左右两侧各保留一个空格</li>
</ul>
<h2 id="常用的输入输出语句"><a href="#常用的输入输出语句" class="headerlink" title="常用的输入输出语句"></a>常用的输入输出语句</h2><pre class="line-numbers language-none"><code class="language-none">alert(msg) // 浏览器弹出框
console.log(msg) // 浏览器控制台打印输出信息
prompt(info) //浏览器弹出输入框，用户可以输入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量即是用于存放数据的容器，我们可以通过变量名获取数据或修改数据，变量的数据存储于内存空间。</p>
<p>变量的使用包含了两个步骤，1、声明变量。2、给变量赋值，声明一个变量并给他赋值，我们称之为变量的初始化。</p>
<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><pre class="line-numbers language-none"><code class="language-none">// 变量声明
var a;

// 变量赋值
a = 100;

// 简化写法
var a = 100;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="更新变量"><a href="#更新变量" class="headerlink" title="更新变量"></a>更新变量</h3><p>一个变量被重新赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准</p>
<pre class="line-numbers language-none"><code class="language-none">// 变量重新赋值，替换掉之前的值
var a = 100;
a = 200;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="同时声明多个变量"><a href="#同时声明多个变量" class="headerlink" title="同时声明多个变量"></a>同时声明多个变量</h3><p>只需写一个 var，多个变量之间使用半角逗号 “,” 隔开，结尾使用 “;”结束，为格式标准化，每个变量最好换一行进行声明。</p>
<pre class="line-numbers language-none"><code class="language-none">// 声明多个变量
var a = 100;
var b = 200;
var c = 300;

// 简化写法 ( 单一var模式 )
var a = 100,
    b = 200,
    c = 300;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="声明变量的特殊情况"><a href="#声明变量的特殊情况" class="headerlink" title="声明变量的特殊情况"></a>声明变量的特殊情况</h3><pre class="line-numbers language-none"><code class="language-none">// 只声明不赋值
var a;
console.log(a); // undefined

// 不声明也不赋值
console.log(a); // 报错

// 不声明直接赋值 (不建议)
a = 100;
console.log(a); // 100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="let-声明变量-ES6"><a href="#let-声明变量-ES6" class="headerlink" title="let 声明变量 (ES6)"></a>let 声明变量 (ES6)</h3><p>let 声明变量的规则与书写格式同 var 大致一致，但有以下几点是和 var 声明变量不同的地方</p>
<h5 id="let-声明变量不可重复声明"><a href="#let-声明变量不可重复声明" class="headerlink" title="let 声明变量不可重复声明"></a>let 声明变量不可重复声明</h5><pre class="line-numbers language-none"><code class="language-none">let a = 1;
let a = b;
// 报错，使用 var 声明变量不存在此问题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h5 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h5><p>let 声明的变量是块级作用域，作用域块是 ES6 新的概念，只能在代码块中有效，块级作用域简单的说就是花括号里面的作用域，如 {} 或 if / else / while / for 等；</p>
<pre class="line-numbers language-none"><code class="language-none">{
  let a = 1;
}
console.log(a);
// 报错，let声明的变量只在声明的块中起作用。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h5><p>不存在变量提升，在声明之前执行代码会报错</p>
<pre class="line-numbers language-none"><code class="language-none">console.log(a);
let a = 1;
// 报错，let声明的变量不会提升<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h5 id="不影响作用域链"><a href="#不影响作用域链" class="headerlink" title="不影响作用域链"></a>不影响作用域链</h5><p>这一点和 var 一致</p>
<pre class="line-numbers language-none"><code class="language-none">{
  let a = a;
  function fn() {
    console.log(a);
  }
}
fn();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="变量的解构赋值-ES6-重学"><a href="#变量的解构赋值-ES6-重学" class="headerlink" title="变量的解构赋值 (ES6) (重学)"></a>变量的解构赋值 (ES6) (重学)</h3><p>Bilibili 视频教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1bS4y1b7NV?p=3">https://www.bilibili.com/video/BV1bS4y1b7NV?p=3</a></p>
<p>ES6 允许按照一定模式从数据或对象中提取值，对变量进行赋值，这被称为解构赋值。</p>
<pre class="line-numbers language-none"><code class="language-none">// 从数组中提取值
const PJ = [3,6,9];
let [a,b,c] = PJ; // 声明了三个变量并将数组中的值分别赋给了三个变量

// 从变量中提取值
const PJ = {
  name: 'PUJI',
  age: 36,
  work: function() {
    console.log(name + age + 'years old');
  }
}
let {name, age, work} = PJ; // 声明了三个变量并将对象中的值分别赋给了三个变量

// 利用数组结构交换变量的数值
let a = 1;
let b = 2;
[a, b] = [b, a]; // a = 2, b = 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="常量-ES6"><a href="#常量-ES6" class="headerlink" title="常量 (ES6)"></a>常量 (ES6)</h2><p>值不可修改的量称为常量。</p>
<h3 id="常量声明"><a href="#常量声明" class="headerlink" title="常量声明"></a>常量声明</h3><p>使用 const 声明常量，常量名使用全大写字母，用于区分变量</p>
<pre class="line-numbers language-none"><code class="language-none">const PI = 3.1415926;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="常量的使用规则"><a href="#常量的使用规则" class="headerlink" title="常量的使用规则"></a>常量的使用规则</h3><ul>
<li>常量声明是必须赋值，并且声明后不可修改；</li>
<li>一般使用大写作为常量名；</li>
<li>常量与 let 声明的变量，也是块级作用域；</li>
<li>对于数组和对象的元素修改，不算做对常量的修改；</li>
<li>数组或对象使用常量来声明更为合适。</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>JavaScript 属于弱类型或者说动态语言，这意味着不用提前声明变量的数据类型，在程序运行过程中，类型会被自动确定。</p>
<p>JavaScript 拥有动态类型，因此变量的数据类型是可以变化的。</p>
<pre class="line-numbers language-none"><code class="language-none">var a = 6; // a 为数字型
var a = 'Puji'; // a 为字符串型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="简单数据类型与复杂数据类型"><a href="#简单数据类型与复杂数据类型" class="headerlink" title="简单数据类型与复杂数据类型"></a>简单数据类型与复杂数据类型</h3><p>目标</p>
<ul>
<li>能够说出简单数据类型的内存分配</li>
<li>能够说出复杂数据类型的内存分配</li>
<li>能够说出简单类型如何传参</li>
<li>能够说出复杂类型如何传参</li>
</ul>
<p>简单数据类型又叫基本数据类型或者值类型，复杂数据类型又叫引用类型。</p>
<ul>
<li>值类型：简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型 String / Number / Boolean / undefined / null (null 返回的是一个空的对象)</li>
<li>引用类型：复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型，通过 new 关键词创建的对象（自定义对象、内置对象）如 Object / Array / Date 等</li>
</ul>
<h5 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h5><ul>
<li>数字型 Number // 默认值 0</li>
<li>字符串型 String // 默认值 “”</li>
<li>布尔型 Boolean // 默认值 false</li>
<li>未定义 Undefined // 默认值 undefined</li>
<li>空值 Null // 默认值 null</li>
<li>Symbol</li>
</ul>
<h5 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h5><ul>
<li>数组 array</li>
<li>对象 object</li>
<li>函数 function</li>
<li>…</li>
</ul>
<h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><p>栈：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈</p>
<p>堆：存储复杂类型，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。</p>
<p>简单数据类型都放在栈中，复杂数据类型首先在栈里存放地址（十六进制）然后再指向堆里的数据</p>
<h2 id="简单数据类型-1"><a href="#简单数据类型-1" class="headerlink" title="简单数据类型"></a>简单数据类型</h2><h3 id="数字型-Number"><a href="#数字型-Number" class="headerlink" title="数字型 Number"></a>数字型 Number</h3><p>数字型包含整数或浮点数，0 与负数。</p>
<pre class="line-numbers language-none"><code class="language-none">var num = 10;
var PI = 3.14;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>数字型进制通常包括 二进制，八进制，十进制与十六进制,在 js 中八进制前价 0，十六进制前价 0x</p>
<pre class="line-numbers language-none"><code class="language-none">// 1、八进制数字序列范围 （0～7）
var num1 = 07;  //对应十进制 7
var num2 = 019;  //对应十进制 19
var num3 = 08;  //对应十进制 0

// 2、十六进制数字序列范围 （0～9以及 a～f）
var num = 0xA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="非数字-NaN"><a href="#非数字-NaN" class="headerlink" title="非数字 NaN"></a>非数字 NaN</h5><p>运算结果不是数字时，会返回 NaN，非数字采用 isNaN() 函数进行判断，如果结果是数字，返回的是 false，如果不是数字返回 true</p>
<pre class="line-numbers language-none"><code class="language-none">var a = 'Hello' - 100; // NaN

isNaN(12) // false
isNaN('Puji') // true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="字符串型-String"><a href="#字符串型-String" class="headerlink" title="字符串型 String"></a>字符串型 String</h3><p>字符串型可以是引号中的任意文本，可以使用单引号或双引号。可以使用单引号与双引号进行嵌套</p>
<pre class="line-numbers language-none"><code class="language-none">var strMsg1 = 'Puji Design'; // 使用单引号表示字符串
var strMsg2 = "Puji Design"; // 使用双引号表示字符串
var strMsg3 = Puji Design; // 报错，会被识别为 js代码，但js没有这样的语法

var strMsg1 = '"Puji" Design';
var strMsg2 = "'Puji' Design";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="字符串不可变"><a href="#字符串不可变" class="headerlink" title="字符串不可变"></a>字符串不可变</h4><p>变量里的字符串值是不可变的，虽然看上去可以改变内容，但其实是地址变了，内存中会心开辟一个内存空间存储新的字符串的值，原来的值还是存在，因此在开发过程中，尽量减少字符串的修改与拼接。</p>
<pre class="line-numbers language-none"><code class="language-none">// 一直在生成新的内存空间
var str = '';
for (var i = 1; i&lt;= 100; i++) {
  str += i;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h4><h5 id="trim"><a href="#trim" class="headerlink" title="trim()"></a>trim()</h5><p>从一个字符串的两端删除空白字符，不影响原先的字符串本身，将返回一个新的字符串。</p>
<pre class="line-numbers language-none"><code class="language-none">var str = '   PUJI Design ';
var str1 = str.trim();
console.log(str1); // PUJI Design<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">// 示例
var input = document.querySelector('input');
var btn = document.querySelector('button');
btn.addEventListener('click', function() {
  var inputValue = input.value.trim(); // 如果输入框内输入的空格或文字首尾两端有空格都进行清除
  if( inputValue === '') {
    alert('请输入内容');
  } else {
    alert('您的内容已成功提交');
  }
})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h4><p>类似 html 里的特殊字符，字符串也有特殊字符，也叫做转义符，转义符必须写到引号内，转义符都是用 \ 开头的，常用的转义符如下：</p>
<pre class="line-numbers language-none"><code class="language-none">\n   换行符，n是newline的意思
\\   斜杠 \
\'   单引号
\"   双引号
\t   tab 缩进
\b   空格，b是blank的意思<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="字符串类型的拼接"><a href="#字符串类型的拼接" class="headerlink" title="字符串类型的拼接"></a>字符串类型的拼接</h4><p>字符串类型的与其他类型进行相拼接，结果都以字符串类型输出。</p>
<pre class="line-numbers language-none"><code class="language-none">// 获取字符串的长度
str.length;

// 字符串的拼接
'PUJI' + ' Design'; // PUJI Design
'PUJI' + 9; //PUJI9
'PUJI' + true; //PUJItrue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="模版字符串-ES6"><a href="#模版字符串-ES6" class="headerlink" title="模版字符串 (ES6)"></a>模版字符串 (ES6)</h4><p>由反引号 “ 包裹的字符串视为模版字符串</p>
<pre class="line-numbers language-none"><code class="language-none">let str = `PUJI Design`;
// 示例1，允许换行
let str = `&lt;ul&gt;             &lt;li&gt;Digital&lt;/li&gt;
             &lt;li&gt;Branding&lt;/li&gt;
             &lt;li&gt;Coding&lt;/li&gt;
           &lt;/ul&gt;`;

// 示例2，拼接变量
let name = 'PUJI';
let out = `${name} Design`;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>在内容中可以直接出现换行符</li>
<li>允许使用变量直接在字符串里进行拼接</li>
</ul>
<h3 id="布尔型-Boolean"><a href="#布尔型-Boolean" class="headerlink" title="布尔型 Boolean"></a>布尔型 Boolean</h3><p>布尔型包含两个值 true 与 false，布尔型同样可以与数字相加</p>
<pre class="line-numbers language-none"><code class="language-none">var flag1 = true; // true 1
var flag2 = false; // false 0

flag1 + 1; // 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="未定义-Undefined"><a href="#未定义-Undefined" class="headerlink" title="未定义 Undefined"></a>未定义 Undefined</h3><p>声明变量但没有赋值的，会有一个默认值 undefined，如果与数字相加，最后的结果是 NaN,如果与字符串相连，结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">// 以下两种形式都属于 undefined
var a;
var a = undefined;

//相加或相连
var a;
12 + a; // NaN
'PUJI' + a; // PUJIundefined<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="空值-Null"><a href="#空值-Null" class="headerlink" title="空值 Null"></a>空值 Null</h3><p>与 undefined 不同，空值如果与数字相加，空值会被视为 0，如果与字符串相连，结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">var a = null;


var a = null;
1 + a; // 1
'PUJI' + a; // PUJInull<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="Symbol-ES6-需重学"><a href="#Symbol-ES6-需重学" class="headerlink" title="Symbol (ES6) (需重学)"></a>Symbol (ES6) (需重学)</h3><p>ES6 引入了一种新的原始值数据类型 Symbol，表示独一无二的值。是一种类似于字符串的数据类型。它的使用场景是给对象添加属性和方法，表示独一无二。</p>
<h5 id="Symbol-特点"><a href="#Symbol-特点" class="headerlink" title="Symbol 特点"></a>Symbol 特点</h5><ul>
<li>Symbol 的值是唯一的，用来解决命名冲突的问题</li>
<li>Symbol 的值不能与其他数据类型进行换算</li>
<li>Symbol 的值不能进行字符串的拼接</li>
<li>Symbol 定义的对象属性不能使用 for…in 循环遍历，但是可以使用 Reflect.ownKeys 来获取对象的所有键名</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">let s1 = Symbol();

let s1 = Symbol('PUJI Design');
let s2 = Symbol('PUJI Design');
console.log(s1 === s2); // false

let s1 = Symbol.for('PUJI Design');
let s2 = Symbol.for('PUJI Design');
console.log(s1 === s2); // true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">let a = {
  [Symbol('name'): 'PUJI';
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h5 id="Symbol-内置值"><a href="#Symbol-内置值" class="headerlink" title="Symbol 内置值"></a>Symbol 内置值</h5><pre class="line-numbers language-none"><code class="language-none">Symbol.hasInstance<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="数据类型的操作"><a href="#数据类型的操作" class="headerlink" title="数据类型的操作"></a>数据类型的操作</h2><h3 id="typeof-获取变量的数据类型"><a href="#typeof-获取变量的数据类型" class="headerlink" title="typeof 获取变量的数据类型"></a>typeof 获取变量的数据类型</h3><pre class="line-numbers language-none"><code class="language-none">var a = 10;
typeof a; // number

var b = 'PUJI';
typeof b; // string

var c = true;
typeof c; // boolean

var d;
typeof d; // undefined

var e = null;
typeof e; // object
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h3><p>即把一种数据类型转换为另一种数据类型，常用的 3 种转换方式</p>
<h5 id="转换为字符串型"><a href="#转换为字符串型" class="headerlink" title="转换为字符串型"></a>转换为字符串型</h5><pre class="line-numbers language-none"><code class="language-none">var num = 1;

// 方法1
num.toString();

// 方法2
String(num);

// 方法3（隐式转换）
num + '';
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="转换为数字型"><a href="#转换为数字型" class="headerlink" title="转换为数字型"></a>转换为数字型</h5><pre class="line-numbers language-none"><code class="language-none">// 将 string 类型转换成整数数值型 (如果有小数点，将在小数点前取整)
parseInt('9'); // 9

// 将 string 类型转换成浮点数值型
parseFloat('6.9'); // 6.9

// 将 string 类型转换成数值型
Number('9'); // 9

// 利用算术运算隐式转换为数值型（隐式转换）
// 使用的符号包括 "-" "*" "/"
'12' - 0; // 12
'9' * '3'; // 27
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>parseInt() 与 parseFloat() 的使用方法基本一致，只是一个取整一个取小数的区别</p>
<pre class="line-numbers language-none"><code class="language-none">parseInt('9');  // 9
parseInt('6.9');  // 6
parseInt('9px');  // 9
parseInt('rem9');  // NaN
parseFloat('6.9');  //6.9
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="转换为布尔型"><a href="#转换为布尔型" class="headerlink" title="转换为布尔型"></a>转换为布尔型</h5><p>Boolean()函数进行转换，代表空、否定的值都会被转换为 false，如 0，NaN，null，undefined。其余都会被转换为 true</p>
<pre class="line-numbers language-none"><code class="language-none">Boolean(''); // false
Boolean(0); // false
Boolean(NaN); // false
Boolean(null); // false
Boolean(undefined); // false
Boolean('PUJI'); // true
Boolean(9); // true
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>运算符 ( Operator ) 也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号。</p>
<p>JavaScript 中常用的运算符有：</p>
<ul>
<li>算数运算符</li>
<li>递增递减运算符</li>
<li>比较运算符</li>
<li>逻辑运算符</li>
<li>赋值运算符</li>
</ul>
<h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>用于执行多个变量或值的算数运算，算数运算符的符号包括加”+”、减”-“、乘”*”、除”/”、取模”%”（取余数）。</p>
<pre class="line-numbers language-none"><code class="language-none">10 + 20; //30
10 - 20; //-10
10 * 20; // 200
10 / 20; //0.5
9 % 2; //1
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>由数字、运算符、变量等以能求得数值的有意义排列方式所得的组合称为表达式。</li>
<li>表达式最终都会有一个结果返回给我们，这个结果称为返回值。</li>
<li>在程序中，是将我们右边表达式计算完毕后把返回值给到左边</li>
<li>浮点数的算数运算里会容易出现问题，尽量避免使用浮点数</li>
</ul>
<h3 id="前后置递增-x2F-递减运算符"><a href="#前后置递增-x2F-递减运算符" class="headerlink" title="前后置递增/递减运算符"></a>前后置递增/递减运算符</h3><p>如果需要反复给数字变量添加或减去 1，可以使用递增 (++) 或递减 (–) 运算符来完成。在 JavaScript 中，递增 (++) 或递减 (–) 即可以放在变量前面，也可以放在变量后面。放在变量前面时，我们可以称为前置递增（递减）运算符，放在变量后面时，我们称为后置递增（递减）运算符。</p>
<pre class="line-numbers language-none"><code class="language-none">// 原理
var num = 1;
num = num + 1;

// 简化写法
var num = 1;
++num
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>前置递增/减和后置递增/减如果单独使用，效果是一样的。前置递增先自加 1，再与表达式计算返回值，后置递增先返回原值与表达式计算，然后再自加 1：</p>
<pre class="line-numbers language-none"><code class="language-none">// 前置递增和后置递增如果单独使用，效果是一样的
var a = 10;
++a; // 11

var b = 10;
b++; // 11

// 示例 2
var a = 10;
++a + 10; // 21

var b = 10;
b++ + 10; //20 (先使用原值与表达式计算，然后在给变量增加一个+1的值)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">// 前置递增与后置递增的练习

var a = 10;
++a;
var b = ++a + 2; // 14

var c = 10;
c++;
var d = c++ + 2; // 13

var e = 10;
var f = e++ + ++e; // 22
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>递增/减运算符必须和变量配合使用；</li>
<li>变量与++/–之间没有空格；</li>
<li>前置递增/减和后置递增/减运算符单独使用时，运行结果相同，与其他代码联用时结果会不同；</li>
<li>开发时，大多情况会使用后置递增/减。</li>
</ul>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>比较运算符也可称为关系运算符，是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值 ( true / false )作为比较运算的结果。</p>
<p>比较运算符的符号：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
<th>案例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;</td>
<td>小于</td>
<td>3 &lt; 6</td>
<td>true</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
<td>3 &gt; 6</td>
<td>false</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
<td>3 &lt;= 3</td>
<td>true</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
<td>3 &gt;= 6</td>
<td>false</td>
</tr>
<tr>
<td>==</td>
<td>判断是否相同 (会转型)</td>
<td>36 == 36</td>
<td>true</td>
</tr>
<tr>
<td>!=</td>
<td>判断是否不相同</td>
<td>36 != 36</td>
<td>false</td>
</tr>
<tr>
<td>=== !==</td>
<td>值和数据类型一起进行对比</td>
<td>36 === ’36’</td>
<td>false</td>
</tr>
</tbody></table>
<ul>
<li>除 “===” 与 “!==” 外，其他的比较运算符都会将字符串型的数据转换为数字型数据</li>
</ul>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>用来进行布尔值运算的运算符，其返回值也是布尔值。在开发中常用于多个条件的判断。</p>
<table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>“逻辑与”，简称”与” and</td>
<td>true &amp;&amp; false</td>
</tr>
<tr>
<td>||</td>
<td>“逻辑或”，简称”或” or</td>
<td>true || false</td>
</tr>
<tr>
<td>!</td>
<td>“逻辑非”，简称”非” not</td>
<td>! true</td>
</tr>
</tbody></table>
<pre class="line-numbers language-none"><code class="language-none">// 逻辑与
3 &gt; 6 &amp;&amp; 3 &gt; 1; //false，所有结果中，只要有一个是假时则返回 false
6 &gt; 3 &amp;&amp; 6 &lt; 9; //true，所有结果都为真时返回 true

// 逻辑或
3 &gt; 6 || 3 &gt; 1; //true，所有结果中，只要有一个是真时则返回 true
6 &lt; 3 || 6 &gt; 9; //false，所有结果都为假时返回 false

//逻辑非
!(6 &lt; 9); //false

//交叉使用
!(6 &lt; 9 || 6 == 3); //false
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="短路运算（逻辑中断）"><a href="#短路运算（逻辑中断）" class="headerlink" title="短路运算（逻辑中断）"></a>短路运算（逻辑中断）</h3><p>当有多个表达式（值）时，左边的表达式值可以确定结果时，就不再继续运算右边的表达式的值。</p>
<p>1、逻辑与</p>
<ul>
<li>表达式 1 &amp;&amp; 表达式 2</li>
<li>如果表达式 1 的值为真，则返回表达式 2</li>
<li>如果表达式 1 的值为假，则返回表达式 1</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">123 &amp;&amp; 456; // 456
0 &amp;&amp; 456; // 0 (所有数字中，除0是假外，其他都是真)
0 &amp;&amp; 1 + 2 &amp;&amp; 123 * 456; // 0
'' &amp;&amp; 1 + 2 &amp;&amp; 123 * 456; //
null &amp;&amp; 0 &amp;&amp; 456; // null
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>2、逻辑或</p>
<ul>
<li>表达式 1 || 表达式 2</li>
<li>如果表达式 1 结果为真，则返回的是表达式 1</li>
<li>如果表达式 1 结果为假，则返回表达式 2</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">123 || 456; // 123
0 || 456; // 456
0 || 1 + 2 || 123 * 456; // 3
'' || 1 + 2 || 123 * 456; // 3
null || 0 || 456; // 456
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">// 逻辑中断的用法示例
var num = 0;
123 || num++;
console.log(num); // 0 由于使用了逻辑中断，num++并没有进行运算
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table>
<thead>
<tr>
<th>赋值运算符</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>直接赋值</td>
<td>var myName = ‘PUJI’;</td>
</tr>
<tr>
<td>+= , -=</td>
<td>加 / 减 一个数后再赋值</td>
<td>var age = 10; age += 5; // 15</td>
</tr>
<tr>
<td>*= , /= , %=</td>
<td>乘 / 除 / 取模 后再赋值</td>
<td>var age = 2; age *= 5; // 10</td>
</tr>
</tbody></table>
<h3 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h3><p>bilibili 视频教程: <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1bS4y1b7NV?p=4">https://www.bilibili.com/video/BV1bS4y1b7NV?p=4</a></p>
<p>展开运算符使用 “…” ，能将数组转换为逗号分隔的参数序列，只要可以遍历的元素都可以使用展开运算符。</p>
<pre class="line-numbers language-none"><code class="language-none">const A = [1,2,3];
function pj() {
  console.log(arguments);
}
pj(...A);

// 数组的合并
const A = [1,2];
const B = [3,4];
const C = [...A, ...B]

// 数组的克隆
const A = [1,2];
const B = [...A];

// 将伪数组转为数组
const DIV = document.querySelectorAll('div');
const DIVARR = [...DIV];
console.log(DIVARR);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>数组的合并可以使用扩展运算符</li>
<li>数组的克隆</li>
</ul>
<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>顺序</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>小括号</td>
<td>()</td>
</tr>
<tr>
<td>2</td>
<td>一元运算符</td>
<td>++ — !</td>
</tr>
<tr>
<td>3</td>
<td>算数运算符</td>
<td>先* / % 后 + –</td>
</tr>
<tr>
<td>4</td>
<td>关系运算符</td>
<td>&gt; &gt;= &lt; &lt;=</td>
</tr>
<tr>
<td>5</td>
<td>相等运算符</td>
<td>== != === !==</td>
</tr>
<tr>
<td>6</td>
<td>逻辑运算符</td>
<td>先 &amp;&amp; 后 ||</td>
</tr>
<tr>
<td>7</td>
<td>赋值运算符</td>
<td>=</td>
</tr>
<tr>
<td>8</td>
<td>逗号运算符</td>
<td>,</td>
</tr>
</tbody></table>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>在一个程序执行的过程中，各条代码的执行顺序对程序的结果是由直接影响的。很多时候我们要通过控制代码的执行顺序来实现我们想要完成的功能。</p>
<p>流程控制主要有三种结构，分别是<strong>顺序结构</strong>、<strong>分支结构</strong>和<strong>循环结构</strong>，这三种结构代表三种代码执行的顺序。</p>
<h2 id="分支流程控制"><a href="#分支流程控制" class="headerlink" title="分支流程控制"></a>分支流程控制</h2><h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><p>由上到下执行代码的过程中，根据不同的条件执行不同的路径代码（执行代码多选一的过程），从而得到不同的结果。</p>
<h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><pre class="line-numbers language-none"><code class="language-none">// 如果if里面的表达式结果为真 (true) 则执行大括号里的代码
if (条件表达式) {
  ...
}

//示例
if ( 6 &gt; 3 ) {
  alert('Yes');
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="if-x2F-else-双分支语句"><a href="#if-x2F-else-双分支语句" class="headerlink" title="if / else 双分支语句"></a>if / else 双分支语句</h3><pre class="line-numbers language-none"><code class="language-none">// 如果if里面的表达式结果为真 (true) 则执行代码1，否则执行代码2
if (条件表达式) {
  代码 1
} else {
  代码 2
}

//示例
if ( 6 &gt; 3 ) {
  alert('Yes');
} else {
  alert('No');
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="if-x2F-else-if-多分支语句"><a href="#if-x2F-else-if-多分支语句" class="headerlink" title="if / else if 多分支语句"></a>if / else if 多分支语句</h3><pre class="line-numbers language-none"><code class="language-none">// 如果if里面的表达式结果为真 (true) 则执行代码1，否则执行代码2
if (条件表达式1) {
  代码 1
} else if (条件表达式2) {
  代码 2
} ... {
  ...
}
else {
  代码n
}

//示例
if ( 6 &lt; 3 ) {
  alert('Yes');
} else if ( 6 &gt; 9 ) {
  alert('Yes');
} else {
  alert('No');
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h3><p>三元表达式也能做一些简单的条件选择，有三元运算符组成的式子称为三元表达式。可以看作是简化版的 if else 语句。三元表达式由符号 “?” 和 “:”组成</p>
<p>条件表达式 ? 表达式 1 : 表达式 2<br>如果条件表达式结果为真，则返回表达式 1 的值，如果条件表达式结果为假，则返回表达式 2 的值。</p>
<pre class="line-numbers language-none"><code class="language-none">var num = 10;
var result = num &gt; 5 ? 'Yes' : 'No'; // Yes
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p>switch 语句也是多分支语句，它用于基于不同的条件来执行不同的代码。当要针对变量设置一系列的特定值的选项时，就可以使用 switch 语句。</p>
<p>执行思路：利用我们的表达式的值和 case 后面的选项值进行对比，如果匹配，就执行该 case 里的语句，如果都不匹配，则执行 default 里的语句。( 如无 default 则什么都不执行 )</p>
<pre class="line-numbers language-none"><code class="language-none">switch(表达式) {
  case value1:
    执行语句1;
    break;
  case value2:
    执行语句2;
    break;
  ...
  default:
    最后的执行语句;
}

switch (2) {
  case 1:
    document.write('1');
    break;
  case 2:
    document.write('2');
    break;
  default:
    document.write('No Result');
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>在开发时，表达式一般会使用变量；</li>
<li>表达式的值和 case 里的值必须全等的时候才属于匹配，如 a === 1；</li>
<li>如果不写条件下的 break 那么代码会一直往下执行；</li>
</ul>
<h3 id="if-与-switch-的区别"><a href="#if-与-switch-的区别" class="headerlink" title="if 与 switch 的区别"></a>if 与 switch 的区别</h3><ul>
<li>一般情况下，他们两个语句可以相互替换；</li>
<li>switch / case 语句通常在有确定的值的情况下使用；</li>
<li>if / else 语句通常用于范围判断 ( 大于、等于某个范围等 )；</li>
<li>switch / case 语句进行条件判断时，会直接执行匹配条件的程序语句，效率更高，而 if / else 语句会逐条进行判断；</li>
<li>当分支比较少时，if / else 执行效率相对会更高，较多时则 switch / case 语句会效率更高。</li>
</ul>
<h2 id="循环流程控制"><a href="#循环流程控制" class="headerlink" title="循环流程控制"></a>循环流程控制</h2><p>目标：</p>
<ul>
<li>能够说出循环的目的是什么</li>
<li>能够说出 for 循环的执行过程</li>
<li>能够使用断点调试来观察代码的执行过程</li>
<li>能够使用 for 循环完成累加求和等案例</li>
<li>能够使用双 for 循环完成乘法表案例</li>
<li>能够说出 while 循环和 do while 循环的区别</li>
<li>能够说出 break 和 continue 的区别</li>
</ul>
<p>循环的内容</p>
<ul>
<li>循环</li>
<li>for 循环</li>
<li>双重 for 循环</li>
<li>while 循环</li>
<li>do while 循环</li>
<li>continue 与 break</li>
</ul>
<h3 id="什么是循环"><a href="#什么是循环" class="headerlink" title="什么是循环"></a>什么是循环</h3><p>循环的目的是可以重复执行某些代码，JS 中主要有三种类型的循环语句，分别是 for 循环、while 循环、do … while 循环。</p>
<p>在程序中，一组被重复执行的语句被称为循环体，能否继续重复执行，取决于循环的终止条件。由循环体及循环的终止条件组成的语句，被称为 循环语句。</p>
<h3 id="for-循环（重点）"><a href="#for-循环（重点）" class="headerlink" title="for 循环（重点）"></a>for 循环（重点）</h3><p>重复执行某些代码，通常与计数有关系</p>
<pre class="line-numbers language-none"><code class="language-none">// 以下三个选项一个不能少
for(初始化变量; 条件表达式; 操作表达式) {
  ...
}

// 示例
for (var i = 1; i &lt;= 100; i++) {
    document.write('Hello');
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>初始化变量，就是用 var 声明的一个普通变量，通常用于作为计数器使用；</li>
<li>条件表达式，就是用来决定每一次循环是否继续执行，也就是终止条件；</li>
<li>操作表达式，是每次循环最后执行的代码，经常用于我们计数器变量进行更新（递增或递减）。</li>
</ul>
<p><strong>for 循环的执行过程</strong></p>
<ol>
<li>首先执行初始化的变量，但这句话在 for 循环里只执行一次；</li>
<li>接着去条件表达式里去判断是否满足条件，如果满足条件则进入第三步，如果不满足则退出循环；</li>
<li>执行循环体；</li>
<li>接着执行操作表达式，然后再进入步骤 2 进行判断，如果条件满足则继续循环，如果不满足则退出循环体。</li>
</ol>
<p><strong>断点调试</strong></p>
<p>断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停止，然后你可以一步步往下调试，调试过程中可以看到各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。</p>
<p>断点调试可以帮组我们观察程序的运行过程，浏览器中检查代码 – sources – 找到需要调试的文件 – 在程序的某一行设置断点-刷新浏览器</p>
<p>代码调试的能力非常重要，只有学会了代码调试，才能学会自己解决 bug 的能力。</p>
<p><strong>双重 for 循环</strong></p>
<p>很多情况下，单层 for 循环并不能满足我们的需求，比如我们要打印一个 5 行 5 列的五角星，打印一个倒三角形等，此时就可以通过循环嵌套来实现。</p>
<pre class="line-numbers language-none"><code class="language-none">for(外层初始化变量; 外层条件表达式; 外层操作表达式) {
    for(里层初始化变量; 里层条件表达式; 里层操作表达式) {
        ...
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>我们可以把里面的循环当作外层循环的执行语句；</li>
<li>外层循环循环一次，里面的循环执行全部。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">for (var i = 1; i &lt;= 3; i++) {
    for (var j = 1; j &lt;= 3; j++) {
        console.log('Outter' + i);
        for (var j = 1; j &lt;= 3; j++) {
            console.log('Inner' + j);
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">var str = '';
for (var i = 1; i &lt;= 10; i++) {
    for (var j = 1; j &lt;= 11 - i; j++) {
        str = str + "A"
    }
    str = str + '\n'
}
console.log(str);

// 结果
AAAAAAAAAA
AAAAAAAAA
AAAAAAAA
AAAAAAA
AAAAAA
AAAAA
AAAA
AAA
AA
A
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p>while 语句可以在条件表达式为真的前提下，循环执行指定的一段代码，直到表达式不为真的时候结束循环。</p>
<pre class="line-numbers language-none"><code class="language-none">while (条件表达式) {
  ...
}

// 示例
var num = 1;
while (num &lt;= 100) {
    console.log('PUJI');
    num++;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>执行思路</p>
<ol>
<li>先执行条件表达式，如果结果为 true ，则执行循环体代码，如果为 false，则退出循环</li>
<li>执行循环体代码</li>
<li>循环体代码执行完毕后，程序会返回第一步继续进行判断，直到循环条件为 false 时，循环结束。</li>
</ol>
<ul>
<li>里面应该有计数器（初始化变量）</li>
<li>循环体中需要有操作表达式，完成计数器的更新，防止死循环</li>
</ul>
<p>for 与 while 循环之间的区别</p>
<ul>
<li>while 循环可做比 for 循环更复杂的选项</li>
</ul>
<h3 id="do-…-while-循环"><a href="#do-…-while-循环" class="headerlink" title="do … while 循环"></a>do … while 循环</h3><p>do … while 语句其实是 while 语句的一个变体，该循环会先执行一次代码块，然后对条件表达式进行判断，如果条件为真，就会重复执行循环体，否则退出循环。</p>
<pre class="line-numbers language-none"><code class="language-none">do {
    ...
} while(条件表达式)

var i = 1;
do {
    console.log('PUJI');
    i++;
} while ( i &lt;= 100 )
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>循环小结</p>
<ul>
<li>js 中循环分为三种，分别是 for、while、do while；</li>
<li>三个循环很多情况下都可以相互替代使用；</li>
<li>如果是用来计算次数，跟数字相关的，三者使用基本相同，只是 for 更常用；</li>
<li>while 和 do while 可以做更复杂的判断条件，比 for 循环更灵活；</li>
<li>while 和 do while 执行顺序不一样，while 先判断后执行，do while 先执行一次在判断是否继续执行</li>
</ul>
<h3 id="continue-与-break"><a href="#continue-与-break" class="headerlink" title="continue 与 break"></a>continue 与 break</h3><p>continue 关键字用于立即跳出本次循环，继续下一次循环（本次循环体中 continue 之后的代码就会少执行一次）。</p>
<p>break 关键字用于立即跳出整个循环（循环结束）</p>
<pre class="line-numbers language-none"><code class="language-none">// continue 的使用
for (var i = 1; i &lt;= 5; i++) {
    if (i == 3) {
        continue;
    }
    console.log(i);
} // 1,2,4,5

// break 的使用
for (var i = 1; i &lt;= 5; i++) {
    if (i == 3) {
        break;
    }
    console.log(i);
} // 1,2
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="迭代器-Iterator-ES6"><a href="#迭代器-Iterator-ES6" class="headerlink" title="迭代器 (Iterator) ES6"></a>迭代器 (Iterator) ES6</h2><p>视频教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1uK411H7on?p=18">https://www.bilibili.com/video/BV1uK411H7on?p=18</a></p>
<p>迭代器是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构之遥部署 Iterator 接口，就可以完成遍历操作。Iterator 接口也就是对象中的一个名为 Symbol.iterator 的属性。ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 使用。迭代器的用途主要用于自定义去遍历数组。</p>
<p>原生具备 Iterator 接口的数据（可用 for…of 遍历）</p>
<ul>
<li>数组 Array</li>
<li>Arguments 参数</li>
<li>Set</li>
<li>Map</li>
<li>String 字符串</li>
<li>TypedArray</li>
<li>NodeList</li>
</ul>
<h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><ul>
<li>创建一个指针对象，指向当前数据结构的起始位置；</li>
<li>第一次调用对象的 next 方法，指针自动指向数据结构的第一个成员；</li>
<li>接下来不断调用 next 方法，指针一直往后移动，知道指向最后一个成员</li>
<li>每次调用 next 方法返回一个包含 value 和 done 属性的对象</li>
</ul>
<h3 id="for-…-of"><a href="#for-…-of" class="headerlink" title="for … of"></a>for … of</h3><p>与 for … in 不同，of 后面返回的是值，而 in 后面返回的是属性名</p>
<pre class="line-numbers language-none"><code class="language-none">for(let v of value) {
  ...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>视频教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1uK411H7on?p=20">https://www.bilibili.com/video/BV1uK411H7on?p=20</a></p>
<p>生成器是一个函数，是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。是一个纯回调函数</p>
<pre class="line-numbers language-none"><code class="language-none">// 声明
function * gen() {
  yield 111;
  yield 222;
  yield 333;
}
// 调用
let iterator = gen();
iterator.next();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">function getUsers() {
    setTimeout(() =&gt; {
        let data = '用户数据';
        iterator.next(data);
    }, 1000)
}
function getOrders() {
    setTimeout(() =&gt; {
        let data = '订单数据';
        iterator.next(data);
    }, 1000)
}
function getGoods() {
    setTimeout(() =&gt; {
        let data = '商品数据';
        iterator.next(data);
    }, 1000)
}
function * gen() {
    let users = yield getUsers();
    console.log(users);
    let orders = yield getOrders();
    console.log(orders);
    let goods = yield getGoods();
    console.log(goods);
}

let iterator = gen();
iterator.next();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Promise-重要-ES6"><a href="#Promise-重要-ES6" class="headerlink" title="Promise (重要) ES6"></a>Promise (重要) ES6</h2><p>视频教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1uK411H7on?p=24">https://www.bilibili.com/video/BV1uK411H7on?p=24</a></p>
<p>Promise 是 ES6 引入的异步编程的新解决方案。语法上 Promise 是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果。</p>
<ul>
<li>Promise 构造函数：Promise (excutor) {}</li>
<li>Promise.prototype.then 方法</li>
<li>Promise.prototype.catch 方法</li>
</ul>
<h2 id="集合-Set-ES6"><a href="#集合-Set-ES6" class="headerlink" title="集合 (Set) ES6"></a>集合 (Set) ES6</h2><p>视频教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1uK411H7on?p=30">https://www.bilibili.com/video/BV1uK411H7on?p=30</a></p>
<p>ES6 提供了新的数据结构 Set 。它类似于数组，但成员的值都是唯一的，集合实现了 Iterator 接口，所以可以使用扩展运算符和 for… of 进行遍历，集合的属性和方法：</p>
<ul>
<li>size 返回集合的元素个数</li>
<li>add 增加一个新元素，返回当前集合</li>
<li>delete 删除元素，返回布尔值</li>
<li>has 检测集合中是否包含某个元素，返回布尔值</li>
</ul>
<h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><pre class="line-numbers language-none"><code class="language-none">// 声明一个集合
let s = new Set(['Digital','Branding','Coding']);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="添加元素-add"><a href="#添加元素-add" class="headerlink" title="添加元素 add"></a>添加元素 add</h3><pre class="line-numbers language-none"><code class="language-none">s.add('UI&amp;UX');
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="删除元素-delete"><a href="#删除元素-delete" class="headerlink" title="删除元素 delete"></a>删除元素 delete</h3><pre class="line-numbers language-none"><code class="language-none">s.delete('UI&amp;UX');
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="检测-has"><a href="#检测-has" class="headerlink" title="检测 has"></a>检测 has</h3><h3 id="集合长度-size"><a href="#集合长度-size" class="headerlink" title="集合长度 size"></a>集合长度 size</h3><h3 id="清空集合"><a href="#清空集合" class="headerlink" title="清空集合"></a>清空集合</h3><pre class="line-numbers language-none"><code class="language-none">s.clear();
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="Map-ES6"><a href="#Map-ES6" class="headerlink" title="Map (ES6)"></a>Map (ES6)</h2><p>ES6 提供了 Map 数据结构，它类似于对象，也是键值对的形式，但是键的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map 也实现了 iterator 接口，所以可以使用扩展运算符和 for…of 进行遍历。Map 的属性和方法</p>
<ul>
<li>size</li>
<li>set</li>
<li>get</li>
<li>has</li>
<li>clear</li>
</ul>
<h2 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 (Array)"></a>数组 (Array)</h2><p>目的：</p>
<ul>
<li>知道为什么要有数组</li>
<li>能够创建数组</li>
<li>能够获取数组中的元素</li>
<li>能够对数组进行遍历</li>
<li>能够给数组新增一个元素</li>
</ul>
<p>数组 ( Array ) 是指将一组相关的数据存储在单个变量名下的集合，其中每个数据被称为元素，在数组中可以存放任意类型的元素。</p>
<h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p>数组的创建方式有两种，一种是通过 new 关键字创建数组，一种是利用数组字面量 ‘[ ]’ 创建数组，两种创建方式的结果相同。</p>
<pre class="line-numbers language-none"><code class="language-none">// 利用 new 关键字创建数组
var arr = new Array(); // 创建了一个空的数组
var arr = new Array(2); // 表示数组长度为2的空数组
var arr = new Array(2,3); // 表示有2个数组元素，分别是2, 3

// 利用数组字面量创建数组（常用）
var 变量名 = []; // 创建了一个空的数组

// 示例
var arr = [1, 2, 'PUJI Design', true];
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>声明数组并赋值，我们称为数组的初始化</li>
<li>数组里的数据一定使用逗号来分隔</li>
<li>数组里的数据被称为数组元素</li>
</ul>
<h3 id="检测是否为数组"><a href="#检测是否为数组" class="headerlink" title="检测是否为数组"></a>检测是否为数组</h3><pre class="line-numbers language-none"><code class="language-none">var arr = [1,2,3];

// 方法1
arr instanceof Array; // true

// 方法2
Array.isArray(arr); // true
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="数组的索引"><a href="#数组的索引" class="headerlink" title="数组的索引"></a>数组的索引</h3><p>索引 ( 下标 )：用来访问数组元素的序号（数组下标从 0 开始）。数组可以通过索引来访问、设置和修改对应的数组元素。如果数组中没有对应的元素，则输出 undefined。</p>
<pre class="line-numbers language-none"><code class="language-none">数组名[索引]
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="获取数组元素"><a href="#获取数组元素" class="headerlink" title="获取数组元素"></a>获取数组元素</h3><pre class="line-numbers language-none"><code class="language-none">var arr = [1, 2, 'PUJI Design', true];
console.log(arr[2]); // PUJI Design
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="获取数组长度-length"><a href="#获取数组长度-length" class="headerlink" title="获取数组长度 .length"></a>获取数组长度 .length</h3><p>使用 “数组名.length” 可以获取数组元素的长度 （数量）。</p>
<pre class="line-numbers language-none"><code class="language-none">var arr = [1, 2, 'PUJI Design', true];
console.log(arr.length);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="新增-x2F-修改数组元素"><a href="#新增-x2F-修改数组元素" class="headerlink" title="新增/修改数组元素"></a>新增/修改数组元素</h3><p>通过修改 length 长度增加数组元素，也可以通过数组的索引号的方式追加或修改数组元素。还可使用 push() / pop() 方法对数组元素进行修改</p>
<pre class="line-numbers language-none"><code class="language-none">// 新增元素 方法1
var arr = [1, 2, 3]; // 声明一个数组变量
arr.length = 4; // 增加数组长度
arr[3] = 4; // 给新增的数组元素赋值

// 新增元素 方法2（追加数组元素）
var arr = [1, 2, 3];
arr[3] = 4;

// 修改元素
var arr = [1, 2, 3];
arr[0] = 4;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="遍历数组（重要）"><a href="#遍历数组（重要）" class="headerlink" title="遍历数组（重要）"></a>遍历数组（重要）</h3><p>遍历数组，也就是把数组中的每一个元素从头到尾都访问一次。同样可以通过 forEach() 方法进行遍历。</p>
<pre class="line-numbers language-none"><code class="language-none">var arr = [1, 2, 'PUJI Design', true];
for (var i = 0; i &lt; 4; i++) {
    console.log(arr[i]);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>因为数组索引号是从 0 开始，所以 i 初始值为 0；</li>
<li>输出的时候 arr[i]</li>
</ul>
<h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><p>在一个数组中筛选大于等于 10 的数字放入一个新的数组</p>
<pre class="line-numbers language-none"><code class="language-none">// 方法1
var arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7];
var newArr = [];
var j = 0;
for (i = 0; i &lt; arr.length; i++) {
    if (arr[i] &gt;= 10) {
        newArr[j] = arr[i];
        j++;
    }
}
console.log(newArr);

// 方法2
var arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7];
var newArr = [];
for (i = 0; i &lt; arr.length; i++) {
    if (arr[i] &gt;= 10) {
        newArr[newArr.length] = arr[i];
    }
}
console.log(newArr);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="数组排序（冒泡排序）"><a href="#数组排序（冒泡排序）" class="headerlink" title="数组排序（冒泡排序）"></a>数组排序（冒泡排序）</h3><p>冒泡排序是一种简单的排序算法，把一系列的数据按照一定的顺序进行排列显示（从小到大或从大到小）。可使用 sort() 方法更方便进行排序。</p>
<pre class="line-numbers language-none"><code class="language-none">var arr = [5, 4, 3, 2, 1];
for (var i = 0; i &lt; arr.length - 1; i++) {
  for (var j = 0; j &lt; arr.length - i - 1; j++) {
    if (arr[j] &gt; arr[j + 1]) {
      var temp = arr[j];
      arr[j] = arr[j + 1];
      arr[j + 1] = temp;
    }
  }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>外层循环控制交换的轮数</li>
<li>内层循环控制每轮交换的次数</li>
</ul>
<h3 id="push-x2F-pop"><a href="#push-x2F-pop" class="headerlink" title="push() / pop()"></a>push() / pop()</h3><pre class="line-numbers language-none"><code class="language-none">// push() 在数组的末尾添加一个或多个数组元素
var arr = [1,2,3];
arr.push(4, 'PUJI');
console.log(arr); // [1, 2, 3, 4, 'PUJI']

// unshift 在数组的开头添加一个或多个数组元素
var arr = [1,2,3];
arr.unshift(4, 'PUJI');
console.log(arr); // [4, 'PUJI', 1, 2, 3]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>push / unshift 是可以给数组追加新的元素</li>
<li>push() / unshift() 参数直接写数组元素</li>
<li>push / unshift 完毕后，返回的结果是新数组的长度</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">// pop() 可以删除数组的最后一个元素
var arr = [1,2,3];
arr.pop();
console.log(arr); // [1, 2]

// shift() 可以删除数组的第一个元素
var arr = [1,2,3];
arr.shift();
console.log(arr); // [2, 3]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>pop() / shift() 不带参数，一次只能删除一个元素</li>
<li>pop() / shift() 的返回值是删除的元素值</li>
</ul>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p>使用 sort() 可以更方便的实现排序功能</p>
<pre class="line-numbers language-none"><code class="language-none">// 基于个字符串的排序
var arr = [5,7,8,6,3,9];
arr.sort();

// 使用函数进行修改
var arr = [12, 5, 7, 36, 9, 6];
arr.sort(function(a, b) {
    return a - b; // 升序排列， b - a 则降序排列
});
console.log(arr);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="indexOf-x2F-lastIndexOf"><a href="#indexOf-x2F-lastIndexOf" class="headerlink" title="indexOf() / lastIndexOf()"></a>indexOf() / lastIndexOf()</h3><p>indexOf()可以根据数组元素的值查询数组中所在的序列，返回一个序列号值</p>
<p>indexOf() 和 lastIndexOf() 都是在数组中查询元素对应的序列号，一个是从前面开始查询，一个是从后面开始查询。</p>
<pre class="line-numbers language-none"><code class="language-none">// 将数组中重复的元素进行筛除
var arr = ['c', 'a', 'z', 'a', 'x', 'a', 'x', 'c', 'b'],
    newArr = [];
for (var i = 0; i &lt; arr.length; i++) {
    if (newArr.indexOf(arr[i]) == -1) {
        newArr.push(arr[i]);
    }
}
console.log(newArr);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>数组转化为字符串有两种方法</p>
<pre class="line-numbers language-none"><code class="language-none">// 方法一
var arr = [1,2,3];
arr.toString(); // 1,2,3

// 方法二
var arr = [1,2,3];
arr.join('-'); // 1-2-3 里面的分隔符可以自定义也可以使用默认
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>用于遍历数组</p>
<pre class="line-numbers language-none"><code class="language-none">array.forEach(function(currentValue[, indexvar arr = [3, 5, 6, 7, 8, 9, 11, 12, 16, 18];
var newArr = arr.some(function(value) {
  return value % 3 == 0;
})
console.log(newArr);, arr]));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>currentValue 数组当前项的值</li>
<li>index 数组当前项的索引</li>
<li>arr 数组对象本身</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">var arr = ['Digital', 'Branding', 'Conding'];
arr.forEach(function(value, index, array) {
  console.log(value + ' : ' + index + ' @ ' + array);
});

// 返回结果
Digital : 0 @ Digital,Branding,Conding
main.js:3 Branding : 1 @ Digital,Branding,Conding
main.js:3 Conding : 2 @ Digital,Branding,Conding
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>根据原有数组返回一个新的数组，需要一个回调函数作为参数，回调函数的返回值称为新数组的元素。</p>
<p>回调函数中有三个参数</p>
<ul>
<li>第一个参数为当前参数</li>
<li>第二个参数为元素的索引</li>
<li>第三个参数为当前数组</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">const arr = [1, 2, 3, 4, 5];
let result = arr.map(item =&gt; item + 1); // [2, 3, 4, 5, 6]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中复合条件的所有元素，主要用于筛选数组。</p>
<pre class="line-numbers language-none"><code class="language-none">array.filter(function(currentValue[, index, arr]));
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>currentValue 数组当前项的值</li>
<li>index 数组当前项的索引</li>
<li>arr 数组对象本身</li>
<li>会返回一个新的数组</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">var arr = [3, 5, 6, 7, 8, 9, 11, 12, 16, 18];
var newArr = arr.filter(function(value) {
  return value % 3 === 0;
})
console.log(newArr); // 3, 6, 9, 12, 18
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h3><p>从数组中找到一个符合条件的第一个值。</p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p>用来合并数组中的元素。</p>
<h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><p>用于检测数组中的元素是否满足指定条件，通俗点说，就是查找数组中是否有满足条件的元素，返回结果是一个布尔值。</p>
<pre class="line-numbers language-none"><code class="language-none">array.filter(function(currentValue, index[, arr]));
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>currentValue 数组当前项的值</li>
<li>index 数组当前项的索引</li>
<li>arr 数组对象本身</li>
<li>返回一个布尔值，如果查找到返回 true，否则返回 false</li>
<li>如果找到第一个满足条件的元素，则终止循环</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">var arr = [3, 5, 6, 7, 8, 9, 11, 12, 16, 18];
var flag = arr.some(function(value) {
  return value % 3 == 0;
})
console.log(flag); // true
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><h2 id="函数-Function"><a href="#函数-Function" class="headerlink" title="函数 (Function)"></a>函数 (Function)</h2><p>目标</p>
<ul>
<li>能说出为什么需要函数</li>
<li>根据语法书写函数</li>
<li>能够根据需求封装函数</li>
<li>能够说出形参和实参的传递过程</li>
<li>能够使用函数的返回值</li>
<li>能够使用 arguments 获取函数的参数</li>
<li>能够说出函数的多种定义和调用方式</li>
<li>能够说出和改变函数内部 this 的指向</li>
<li>能够说出严格模式的特点</li>
<li>能够把函数作为参数和返回值传递</li>
<li>能够说出闭包的作用</li>
<li>能够说出递归的两个条件</li>
<li>能够说出深拷贝和浅拷贝的区别</li>
</ul>
<h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>在 js 里，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用，这种情况下使用函数就可以解决复用的问题。函数就是封装了一段可重复调用执行的代码块，通过此代码块可实现代码的多次重复使用。</p>
<ul>
<li>每个函数都有一个原型对象</li>
</ul>
<h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><p>视频教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17y4y1J7L1?p=51">https://www.bilibili.com/video/BV17y4y1J7L1?p=51</a></p>
<p>函数的声明方式有三种方式，使用 function 关键字进行申明（命名函数），使用函数表达式进行申明（匿名函数），利用构造函数创建函数对象实例。</p>
<p>函数属于对象类型</p>
<pre class="line-numbers language-none"><code class="language-none">// 自定义函数（命名函数）
function 函数名() {
  ...
}

// 函数表达式（匿名函数）
var fn = function () {
  ...
}

// 利用构造函数创建函数对象实例 (效率较低，不常用)
var fn = new Function('参数1', '参数2', '函数体')
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><p>视频教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17y4y1J7L1?p=52">https://www.bilibili.com/video/BV17y4y1J7L1?p=52</a></p>
<pre class="line-numbers language-none"><code class="language-none">// 调用普通函数(以上三种形式创建的函数都是普通函数)
fn();

// 调用对象函数
var obj = {
  fn: function() {
    ...
  }
}
obj.fn();

// 调用构造函数
function Fn() {
  ..
}
new Fn();

// 除以上三种形式外，还包括事件绑定函数、定时器函数、立即执行函数。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>函数是执行某件事情，函数名一般使用动词</li>
<li>声明函数本身不会执行，只有调用了函数才会执行</li>
</ul>
<p>进阶参考： <a target="_blank" rel="noopener" href="https://lab.puji.design/javascript-four-method-of-function-call-mode/">JS 中四种函数的调用模式</a></p>
<h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p>函数的参数分为两种类型，形参与实参，在声明函数的圆括号里的参数称为形参，在函数调用的圆括号里的参数称为实参。</p>
<pre class="line-numbers language-none"><code class="language-none">// 声明函数
function 函数名(形参1, 形参2, ...) {
  //函数体
}

// 调用函数
函数名(实参1,实参2, ...);

// 示例
function test(a,b,c) {
  return a + b + c;
}
test(1,2,3);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>形参是接收实参的，可以看作是一个不用声明的变量</li>
<li>函数可以带参数也可以不带，并且带参数时数量不限</li>
<li>多个参数之间使用逗号分隔</li>
<li>如果形参与实参的数量一致，则正常输出结果</li>
<li>如果实参的数量多余形参的数量，会取到形参的数量进行执行</li>
<li>如果实参的数量少余形参的数量，多余的形参会被定义为 undefined</li>
<li>建议尽量让形参与实参的数量一致</li>
</ul>
<h3 id="参数的默认值"><a href="#参数的默认值" class="headerlink" title="参数的默认值"></a>参数的默认值</h3><pre class="line-numbers language-none"><code class="language-none">// 示例
function test(a,b,c=10) {
  return a + b + c;
}
test(1,2);

// 示例 2
function connect({host, username, password, port='80'}) {
  console.log('ok');
}
conncet({
  host: 'puji.design',
  username: 'root',
  password: 'root',
  port: '8888'
})
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>参数默认值，一般需要从右往左添加</li>
<li>参数的默认值可以与解构赋值共同使用</li>
</ul>
<h3 id="return-返回值"><a href="#return-返回值" class="headerlink" title="return 返回值"></a>return 返回值</h3><p>将函数的值返回给调用者，此时可以通过使用 return 语句来实现。</p>
<pre class="line-numbers language-none"><code class="language-none">function 函数名() {
  return 需要返回的结果;
}
函数名();

// 示例
function getResult() {
  return 'PUJI';
}
getResult(); // getResult() = 'PUJI'

// 示例2
var sum = 0;
function getSum(num1, num2) {
    for (var i = num1; i &lt;= num2; i++) {
        sum += i;
    }
    return sum;
}
console.log(getSum(1, 100)); // 5050

// 示例3
function getMax(num1,num2) {
  return num1 &gt; num2 ? num1 : num2;
}
console.log(getMax(1, 100));  // 100

// 示例4
function getMax(arr) {
    var maxNum = arr[0];
    for (var i = 1; i &lt; arr.length; i++) {
        if (maxNum &lt; arr[i]) {
            maxNum = arr[i];
        }
    }
    return maxNum;
}
console.log(getMax([5, 2, 99, 101, 67, 77]));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>函数只是实现某种功能，最终的结果需要返回给函数的调用者</li>
<li>只要函数遇到 return ，就把后面的结果返回给函数的调用者</li>
<li>return 语句有终止函数的作用，遇到 return 之后的代码不被执行</li>
<li>return 只能返回一个值，如果需要输出多个值，可以利用数组或对象完成</li>
<li>函数都是有返回值的，如果没有 return 将返回 undefined，有 return 则返回 return 语句中的值</li>
</ul>
<h3 id="break-continue-return-的区别"><a href="#break-continue-return-的区别" class="headerlink" title="break, continue, return 的区别"></a>break, continue, return 的区别</h3><ul>
<li>break:结束当前的循环体（如 for，while）</li>
<li>continue:跳出本次循环，继续执行下一次循环（如 for，while）</li>
<li>return:可在循环或函数中使用，不仅可以退出循环或函数，还能返回 return 语句中的值</li>
</ul>
<h3 id="arguments-参数"><a href="#arguments-参数" class="headerlink" title="arguments 参数"></a>arguments 参数</h3><p>当我们不确定有多少个参数传递的时候，可以用 arguments 来获取，在 javascript 中，arguments 实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。</p>
<pre class="line-numbers language-none"><code class="language-none">function 函数名(){
  arguments; // 里面存储了所有传递过来的实参
  arguments.length; // 5
  arguments[2]; // 2
}
函数名(1,2,3,4,5);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>arguments 是以一个伪数组的形式来展示的，伪数组的特点以下：</p>
<ul>
<li>具有 length 属性</li>
<li>按索引方式储存数据</li>
<li>不具有数组的 push(), pop() 等方法</li>
</ul>
<h3 id="rest-参数-ES6"><a href="#rest-参数-ES6" class="headerlink" title="rest 参数 (ES6)"></a>rest 参数 (ES6)</h3><p>用于获取函数的实参，代替 arguments</p>
<pre class="line-numbers language-none"><code class="language-none">function date(...args){
  console.log(args);
}
date(1,2,3); // 返回[1,2,3]

function date(a,b,...args){
  console.log(args);
}
date(1,2,3,4,5,6); // 返回[3,4,5,6]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>rest 参数前面为三个 … 后面为自定义的标识符；</li>
<li>rest 参数返回的是一个数组，而 argument 返回的是一个对象;</li>
<li>rest 参数必须放到参数的最后。</li>
</ul>
<h3 id="函数可以调用其他函数"><a href="#函数可以调用其他函数" class="headerlink" title="函数可以调用其他函数"></a>函数可以调用其他函数</h3><p>因为每个函数都是独立的代码块，用于完成特殊任务，因此经常会用到函数互相调用的情况。</p>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>前面一种函数的声明方式，也叫命名函数，以下的函数声明，fn 只是变量名，因此此函数没有名称，也叫匿名函数。</p>
<pre class="line-numbers language-none"><code class="language-none">// 函数表达式(匿名函数)
var 变量名 = function(){};

// 示例
var fn = function(){};

// 调用函数
fn();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>函数没有名称，声明的名称属于变量名</li>
<li>函数表达式声明方式与声明变量差不多，只不过变量里存的是值，而函数表达式里存的是函数</li>
<li>同样可以进行参数的传递</li>
</ul>
<h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>一般的函数声明后需调用才可执行，而立即执行函数无需调用立马可以执行。主要创建一个独立的作用域</p>
<pre class="line-numbers language-none"><code class="language-none">// 写法 1
(function() {})();

// 写法 2
(function() {}());

(function(a, b) {
  console.log(a + b);
})(1, 2);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>立即执行函数也可以进行参数传递</li>
<li>立即执行函数可以是匿名函数，也可以命名；</li>
<li>他的最大作用就是独立创建了一个作用域</li>
</ul>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出。</p>
<pre class="line-numbers language-none"><code class="language-none">// 接收函数作为参数
function fn(callback) {
  callback &amp;&amp; callback();
}
fn(function() {alert('PUJI')});

// 将函数作为返回值输出
function fn(callback) {
  return function() {}
}
fn();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="箭头函数-ES6"><a href="#箭头函数-ES6" class="headerlink" title="箭头函数 (ES6)"></a>箭头函数 (ES6)</h3><p>bilibili 视频教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1bS4y1b7NV?p=5">https://www.bilibili.com/video/BV1bS4y1b7NV?p=5</a></p>
<p>ES6 允许使用箭头 =&gt; 定义函数</p>
<pre class="line-numbers language-none"><code class="language-none">// 以前声明函数的方法
var fn = function() {
  ..
}

// 箭头简化写法
let fn = () =&gt; {
  ..
}

// 省略小括号
let fn = n =&gt; {
  return n;
}
console.log(fn(3));

// 省略花括号
let fn = (n) =&gt; n * n;
console.log(fn(3));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">// this 指向声明函数的作用域
let ad = document.querySelector('div');
ad.addEventListener('click', function(){
  setTimeout(() =&gt; {
    this.style.background = 'blue';
  },1000);
});

// 代码简化
const arr = [1,2,3,4,5,6,9];
const result = arr.filter( item =&gt; item % 2 === 0; )
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>箭头函数的 this 是静态的，this 始终指向函数声明时所在作用域下的 this 的值；</li>
<li>不能作为构造函数实例化对象；</li>
<li>不能使用 arguments 变量；</li>
<li>当形参有且只有一个的时候可以省略小括号；</li>
<li>当执行体只有一条语句的时候可以省略花括号，并且 return 也必须省略；</li>
<li>箭头函数适合与 this 无关的回调、定时器、数组的方法回调。</li>
</ul>
<h3 id="函数的-this-指向"><a href="#函数的-this-指向" class="headerlink" title="函数的 this 指向"></a>函数的 this 指向</h3><p>视频教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17y4y1J7L1?p=53">https://www.bilibili.com/video/BV17y4y1J7L1?p=53</a></p>
<p>this 的指向，是当我们调用函数的时候确定的，调用方式的不同决定了 this 的指向不同，一般指向我们的调用者</p>
<table>
<thead>
<tr>
<th>调用方式</th>
<th>this 指向</th>
</tr>
</thead>
<tbody><tr>
<td>普通函数调用</td>
<td>普通模式：window 严格模式：undefine</td>
</tr>
<tr>
<td>构造函数调用</td>
<td>实例对象，原型对象里的方法也指向实例对象。</td>
</tr>
<tr>
<td>对象方法调用</td>
<td>该方法所属对象</td>
</tr>
<tr>
<td>事件绑定调用</td>
<td>绑定事件对象</td>
</tr>
<tr>
<td>定时器函数</td>
<td>window</td>
</tr>
<tr>
<td>立即执行函数</td>
<td>window</td>
</tr>
</tbody></table>
<p>JavaScript 为我们提供了一些函数方法来帮我们处理函数内部 this 的指向问题，常用的有 bind()、call()、apply() 三种方法。</p>
<h3 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h3><p>视频教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17y4y1J7L1?p=34">https://www.bilibili.com/video/BV17y4y1J7L1?p=34</a><br>视频教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17y4y1J7L1?p=54">https://www.bilibili.com/video/BV17y4y1J7L1?p=54</a></p>
<p>可以调用这个函数，并且修改函数运行时的 this 指向</p>
<pre class="line-numbers language-none"><code class="language-none">fn.call(thisAsg, arg1, arg2, ...);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>thisArg: 当前调用函数 this 的指向对象</li>
<li>arg1, arg2: 传递的其他参数</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">// 常规调用方法
function fn() {
  console.log('PUJI');
}
fn();

// 使用 call() 方法进行调用
function fn() {
  console.log(this);
}
fn.call(); // this 指向 window

// 修改 this 指向
function fn() {
  console.log(this.name);
}
var o = {
  name: 'PUJI'
}
fn.call(o); // 此时这个函数的 this 就指向了 o 这个对象

// 传递参数
function fn(a, b) {
  console.log(this.name);
  console.log(a + b);
}
var o = {
  name: 'PUJI'
}
fn.call(o, 1, 2); // call 只是修改 this 的指向，指向的对象不参与参数的传递
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>call() 方法可以调用函数</li>
<li>改变函数运行时的 this 指向</li>
<li>他的主要作用是可以实现继承</li>
</ul>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p>视频教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17y4y1J7L1?p=55">https://www.bilibili.com/video/BV17y4y1J7L1?p=55</a></p>
<p>利用 apply() 方法调用一个函数，简单理解为调用函数的方式，但是他可以改变函数的 this 指向</p>
<pre class="line-numbers language-none"><code class="language-none">fn.apply(thisArg, [argsArray])
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>thisArg: 在函数运行时指定的 this 值</li>
<li>argsArray: 传递的值，必须包含在数组里</li>
<li>返回值就是函数的返回值，因为他就是调用函数</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">var o = {
  name: 'PUJI'
}
function fn(arr) {
  console.log(arr);
}
fn.apply(o, ['Design']); // 返回字符串

// 借助于数学内置对象求最大值
var arr = [1,2,3,5,6,9];
var result = Math.max.apply(Math, arr);
console.log(result);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>也是调用函数，同样可以改变函数内部的 this 指向</li>
<li>但是他的参数必须是数组（伪数组）</li>
<li>返回的值是一个字符串</li>
<li>主要作用，比如可以利用 apply 借助于数学内置对象求最大值</li>
</ul>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><p>视频教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17y4y1J7L1?p=57">https://www.bilibili.com/video/BV17y4y1J7L1?p=57</a></p>
<p>bind() 不会调用函数，但是能改变函数内部 this 指向</p>
<pre class="line-numbers language-none"><code class="language-none">fn.bind(thisArg, arg1, arg2, ...);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">var o = {
  name: 'PUJI'
}
function fn() {
  console.log(this);
}
var f = fn.bind(o);
f();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>thisArg: 函数运行时 this 的指向对象</li>
<li>arg1, arg2: 传递的其他参数</li>
<li>不会调用原来的函数，可以改变原来函数内部的 this 指向</li>
<li>返回由指定的 this 值和初始化参数改造的原函数拷贝</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">// bind 应用案例示例
var btn = document.querySelector('button');
btn.addEventListener('click', function() {
  this.disabled = true;
  setTimeout(function () {
    this.disabled = false; // 此时定时器里的 this 指向的是 btn 而不是 window 了
  }.bind(this), 3000);
})
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17y4y1J7L1?p=70">https://www.bilibili.com/video/BV17y4y1J7L1?p=70</a></p>
<p>如果一个函数在内部可以调用其自身，那么这个函数就是递归函数。递归函数的作用和循环效果一样。由于递归很容易发生”栈溢出”错误 ( Stack overflow )，所以必须加上退出条件 return。</p>
<pre class="line-numbers language-none"><code class="language-none">function fn() {
  if() {
    return;
  }
  fn();

}
fn();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="利用递归函数求数学题"><a href="#利用递归函数求数学题" class="headerlink" title="利用递归函数求数学题"></a>利用递归函数求数学题</h4><pre class="line-numbers language-none"><code class="language-none">// 示例 1
function fn(n) {
  if(n === 1) {
    return 1;
  }
  return n * fn(n - 1);
}
fn(6);

// 示例 2
function fn(n) {
  if(n ===1 || n === 2) {
    return 1;
  }
  return fn(n - 1) + fn(n - 2);
}
fn(6)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="利用递归函遍历数据"><a href="#利用递归函遍历数据" class="headerlink" title="利用递归函遍历数据"></a>利用递归函遍历数据</h4><pre class="line-numbers language-none"><code class="language-none">var data = [
  {
    id: 1,
    name: 'Design',
    cats: [
      {
        id: 11,
        name: 'UI&amp;UX'
      }, {
        id: 12,
        name: 'Branding'
      }, {
        id: 13,
        name: 'Website'
      }
    ]
  },
  {
    id: 2,
    name: 'Coding'
  }
]
var o = {};
function getID(json, id) {
  json.forEach( element =&gt; {
    if(element.id === id) {
      o = element
      return element;
    } else if ( element.cats &amp;&amp; element.cats.length &gt;0 ) {
      o = getID( element.cats, id);

    }
  });
  return o;
}
console.log(getID(data, 11));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="检测属性"><a href="#检测属性" class="headerlink" title="检测属性"></a>检测属性</h2><pre class="line-numbers language-none"><code class="language-none">let arr = ['PUJI', 'Design']
console.log(arr.hasOwnProperty('length')) // 只检测自己是否有此属性
console.log('length' in arr) // 检测自己以及父级是否有此属性
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>目标：</p>
<ul>
<li>能够说出 javascript 的两种作用域</li>
<li>能够区分全局变量和局部变量</li>
<li>能够说出如何在作用域链中查找变量的值</li>
</ul>
<h3 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h3><p>一段程序代码中所用到的名字并不总是有效可用的，而限定这个名字的可作用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，更重要的是减少了名字的冲突。</p>
<p>js 的作用域分为两种 (es6 之前)</p>
<ul>
<li>全局作用域：在文件的最外层定义的变量就是在全局作用域里</li>
<li>局部作用域：在函数内定义的变量就是局部作用域，这个代码名字只在函数内部起效果，因此也叫函数作用域。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">var a = 10;
function fn() {
  var b = 20;
}
// a 为全局作用域的变量，b 为局部作用域的变量
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>全局作用域与局部作用域的相同的变量不会相互影响</li>
</ul>
<h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>在 javascript 中，根据作用域的不同，变量也可以分为全局变量与局部变量</p>
<ul>
<li>全局变量：在全局作用域下的变量就是全局变量，在全局下都可使用</li>
<li>局部变量：在局部作用域下的变量，或者说是在函数内部的变量就是局部变量</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">var a = 1;
function fn() {
  var b = 2;
  c = 3;
}
// a全局变量
// b局部变量
// c全局变量
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>如果在函数内部没有声明直接赋值的变量，也属于全局变量</li>
<li>函数的形参也可以看作局部变量</li>
<li>从执行效率来看，全局变量只有浏览器关闭的时候才会销毁，比较占内存资源，局部变量当程序执行完毕就会销毁，比较节约内存资源</li>
</ul>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>根据内部函数可以访问外部函数变量变量的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链，作用域链采用就近原则，即查找到最近一层的数据后就停止再向外去找</p>
<h3 id="块级作用域-ES6"><a href="#块级作用域-ES6" class="headerlink" title="块级作用域 (ES6)"></a>块级作用域 (ES6)</h3><p>使用花括号 {} 包裹，里面的作用域就属于块级作用域，块级作用域里的变量，只在当前块中有效。块级作用域的好处在于，如果项目比较复杂的情况下，有内层变量覆盖外层变量的风险。</p>
<pre class="line-numbers language-none"><code class="language-none">if(true) {
  块级作用域
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="闭包-Closure"><a href="#闭包-Closure" class="headerlink" title="闭包 (Closure)"></a>闭包 (Closure)</h2><p>视频教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17y4y1J7L1?p=63">https://www.bilibili.com/video/BV17y4y1J7L1?p=63</a></p>
<p>闭包是指有权<strong>访问另一个函数作用域</strong>中变量的<strong>函数</strong>。简单理解就是，一个作用域可以访问另外一个函数内部的局部变量。闭包的作用是延伸了变量的作用范围。</p>
<h3 id="案例示范"><a href="#案例示范" class="headerlink" title="案例示范"></a>案例示范</h3><h4 id="循环注册点击事件"><a href="#循环注册点击事件" class="headerlink" title="循环注册点击事件"></a>循环注册点击事件</h4><pre class="line-numbers language-none"><code class="language-none">// 手动获取索引号方式
var items = document.querySelectorAll('li');
for ( i = 0; i &lt; items.length; i++ ) {
  items[i].index = i; // 获取索引号
  items[i].addEventListener('click', function () {
    console.log(this.index);
  })
}

// 利用闭包方式获得索引号 (相比第一种效率更低)
var items = document.querySelectorAll('li');
for ( i = 0; i &lt; items.length; i++ ) {
  // 利用 for 循环创建了多个立即执行函数
  (function (i) {
    items[i].addEventListener('click', function () {
      console.log(i);
    })
  })(i);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="循环中的-setTimout"><a href="#循环中的-setTimout" class="headerlink" title="循环中的 setTimout()"></a>循环中的 setTimout()</h4><pre class="line-numbers language-none"><code class="language-none">var items = document.querySelectorAll('li');
for ( i = 0; i &lt; items.length; i++ ) {
  (function (i) {
    setTimeout(function() {
      console.log(i);
    }, 3000);
  })(i);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="出租车计价案例"><a href="#出租车计价案例" class="headerlink" title="出租车计价案例"></a>出租车计价案例</h4><pre class="line-numbers language-none"><code class="language-none">var car = (function() {
  var start = 13;
  var total = 0;
  return {
    price: function(n) {
      if(n &lt;= 3) {
        total = start;
      } else {
        total = start + (n-3)*5
      }
      return total;
    },
  }
})();
console.log(car.price(6));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h2><p>浅拷贝只是拷贝一层，更深层次的对象级别的只拷贝引用。深拷贝可拷贝多层，每一层级的数据都会被拷贝。</p>
<p>在 ES6 中新增了浅拷贝的方法 Object.assign( target, …sources )</p>
<pre class="line-numbers language-none"><code class="language-none">// 浅拷贝
var obj = {
  name: 'PUJI',
  age: 36,
  cats: {
    work1: 'Digital',
    work2: 'Branding',
    work3: 'Coding'
  }
};
var o = {};
for(var k in obj) {
  // k 是属性名，obj[k] 是属性值
  o[k] = obj[k];
}
console.log(o);

// assign() 方法
var obj = {
  name: 'PUJI',
  age: 36,
  cats: {
    work1: 'Digital',
    work2: 'Branding',
    work3: 'Coding'
  }
};
var o = {};
Object.assign(o, obj);
console.log(o);

// 浅拷贝可以拷贝第一层的数据，更深层的对象数据只会拷贝对象的指向地址，所以修改此对象的数据，另一个对象里的数据也会一起更改
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">// 深拷贝
var obj = {
  name: 'PUJI',
  age: 36,
  cats: {
    work1: 'Digital',
    work2: 'Branding',
    work3: 'Coding'
  },
  num: [3, 6, 9]
};
var o = {};
function deepCopy(newObj, oldObj) {
  for( var k in oldObj ) {
    // 判断属性值属于哪种数据类型
    var element = oldObj[k];
    if( element instanceof Array ) {
      newObj[k] = [];
      deepCopy(newObj[k], element);
    } else if( element instanceof Object ) {
      newObj[k] = {};
      deepCopy(newObj[k], element);
    } else {
      newObj[k] = element;
    }
  }
}
deepCopy(o, obj)
console.log(o);;

// 深拷贝可以拷贝所有层级的数据，会把深层级的数据另外开辟一个空间进行存储，所以修改此对象的数据，不会对另一个对象里的数据造成影响
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="对象-Object-重要"><a href="#对象-Object-重要" class="headerlink" title="对象 (Object) (重要)"></a>对象 (Object) (重要)</h2><p>目标</p>
<ul>
<li>为什么需要对象</li>
<li>能够使用字面量创建对象</li>
<li>能够使用构造函数创建对象</li>
<li>能够说出 new 的执行过程</li>
<li>能够遍历对象</li>
</ul>
<p>在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，如字符串，数值，数组函数等。对象属于复杂数据类型</p>
<p>JavaScript 中的对象分为 3 种：自定义对象、内置对象、浏览器对象。前面两种对象是 js 基础内容，属于 ECMAScript；第三个浏览器对象属于 JS 独有的。</p>
<h5 id="对象是由属性和方法组成的"><a href="#对象是由属性和方法组成的" class="headerlink" title="对象是由属性和方法组成的"></a>对象是由属性和方法组成的</h5><ul>
<li>属性：事物的特征，在对象中用属性来表示（常用名次）；</li>
<li>方法：事物的行为，在对象中用方法来表示（常用动词）。</li>
</ul>
<h5 id="为什么需要对象"><a href="#为什么需要对象" class="headerlink" title="为什么需要对象"></a>为什么需要对象</h5><p>在保存一个值时，可以使用变量，保存多个值（一组值）可以使用数组，但如果需要保存多维的数据，JS 中的对象表达结构更清晰，更强大。</p>
<h3 id="创建对象的三种方式"><a href="#创建对象的三种方式" class="headerlink" title="创建对象的三种方式"></a>创建对象的三种方式</h3><p>在 JavaScript 中 我们可以采用三种方式创建对象</p>
<ul>
<li>利用字面量创建对象（常用）:就是花括号 {} 里包含了表达这个具体事物（对象）的属性和方法；</li>
<li>利用 new Object 创建对象；</li>
<li>利用构造函数创建对象。</li>
</ul>
<h3 id="利用字面量创建对象"><a href="#利用字面量创建对象" class="headerlink" title="利用字面量创建对象"></a>利用字面量创建对象</h3><pre class="line-numbers language-none"><code class="language-none">var obj = {}; // 创建了一个空的对象
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">var obj = {
  uname: 'Wewe',
  age: 36,
  sex: 'male',
  sayHi: function() {
    ...
  }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>里面的属性或方法我们采取键值对的形式，即名称与值，值可以是任何类型；</li>
<li>多个属性或者方法中间用逗号隔开；</li>
<li>方法冒号后面跟的是一个匿名函数。</li>
</ul>
<h3 id="new-关键字创建对象"><a href="#new-关键字创建对象" class="headerlink" title="new 关键字创建对象"></a>new 关键字创建对象</h3><pre class="line-numbers language-none"><code class="language-none">// 利用 new Object 创建对象
var obj = new Object(); //创建了一个空的对象

obj.uname = 'Wewe';
obj.age = 36;
obj.sex = 'male'
obj.sayHi = function() {}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>利用等号赋值的方法添加对象的属性和方法；</li>
<li>每个属性和方法之间使用分号分隔；</li>
<li>调用与前面一样。</li>
</ul>
<h3 id="利用构造函数创建对象（重要）"><a href="#利用构造函数创建对象（重要）" class="headerlink" title="利用构造函数创建对象（重要）"></a>利用构造函数创建对象（重要）</h3><p>ES6 新增了面向对象的概念，和此方法类似。</p>
<p>由于前面两种创建对象的方式一次只能创建一个对象，如果需要一次创建多个对象，且很多属性和方法是大致相同的，因此我们可以利用函数的方法重复这些相同的代码，又因为这个函数里面封装的不是普通代码，而是对象，我们就把这个函数称为构造函数。</p>
<p>构造函数是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里。</p>
<pre class="line-numbers language-none"><code class="language-none">function 构造函数名() {
  this.属性 = 值；
  this.方法 = function() {
    ...
  }
}
new 构造函数名();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">// 示例
function Star(uname, age, sex) {
  this.name = uname;
  this.age = age;
  this.sex = sex;
}
Star.prototype.sing = function(song) {
  console.log(song);
}
var ldh = new Star('刘德华', '36', '男');
ldh.sing('冰雨');
var zxy = new Star('张学友', '39', '男');
zxy.sing('李香兰');
console.log(ldh);
console.log(zxy);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>构造函数名字首字母需要大写；</li>
<li>构造函数中的属性与方法指向构造函数的原型对象；</li>
<li>通过 new 构造出的子类，将自动同函数的原型对象进行关联；</li>
<li>每个子类还可拥有自己独立的属性和方法（ 尽量将每个子类相同的方法都放在原型对象里 ）；</li>
<li>原型对象相当于所有构造出的实例对象的公共区域；</li>
<li>设置属性时，只能通过原型对象自己去设置这个属性，如 “Star.prototype.name = 123” ;</li>
<li>如果实例对象设置一个跟原型对象相同属性的值时，会自动添加一个自己的属性，如 “ldh.name = 456” ;</li>
<li>构造函数中不需要 return 就可以返回结果，返回的结果是 this 对象，如果写了 return 将返回 return 的值；</li>
<li>我们只要调用一次构造函数就创建了一个新的实例对象</li>
<li>属性和方法前面必须添加 this</li>
<li>属性在构造函数中添加，尽量不要在原型中添加属性（ 如果是常量可以添加在原型中 ），方法尽量在原型中添加。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">// 标准用法结构
function Studio() {
  this.name = 'PUJI';
  this.age = 36;
}
Studio.prototype.work = function() {
  console.log(this.name + this.age + 'years old.');
}
var a = new Studio();
a.work();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">// 改进1，将属性参数化
function Studio(name, age) {
  this.name = 'PUJI';
  this.age = 36;
}
Studio.prototype.work = function(work) {
  console.log(this.name + this.age + 'years old.' + ' And we lover ' + work);
}
var a = new Studio( 'PUJI', 36 );
a.work('Design');
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">// 改进2，将参数设为对象
function Studio(opt) {
  this.name = opt.name;
  this.age = opt.age;
}
Studio.prototype.work = function() {
  console.log(this.name + this.age + 'years old.' + ' And we lover ' + work);
}
var a = new Studio( {
  name: 'PUJI',
  age: 36
} );
a.work('Design');
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">// 改进3，将属性与方法统一在一个对象
function Studio(opt) {
    this._init(opt); // 使用下划线定义，用于区分此方法仅在内部使用
  }
  Studio.prototype = {
      constructor: Studio, // 指向回原来的构造函数
    _init: function(opt) {
      this.name = opt.name;
      this.age = opt.age;
    },
    work: function(work) {
      console.log(this.name + this.age + 'years old.' + ' And we lover ' + work);
    }
  }
  var a = new Studio( {
    name: 'PUJI',
    age: 36,
    work: 'Design'
  } );
  console.log(Studio.prototype.constructor);
  console.log(a.__proto__.constructor);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="new-关键词的执行过程"><a href="#new-关键词的执行过程" class="headerlink" title="new 关键词的执行过程"></a>new 关键词的执行过程</h5><ol>
<li>通过 new 构造子类，生成一个新的实例对象；</li>
<li>在内存中创建一个空的 this 对象；</li>
<li>this 对象指向构造函数原型对象；</li>
<li>执行构造函数里的代码，给 this 对象添加属性和方法。</li>
</ol>
<h5 id="构造函数与对象之间的联系"><a href="#构造函数与对象之间的联系" class="headerlink" title="构造函数与对象之间的联系"></a>构造函数与对象之间的联系</h5><ul>
<li>构造函数是抽象了对象的公共部分，封装到了函数里面，泛指的某一大类，</li>
<li>对象是特指某一个，通过 new 关键字创建对象的过程我们也称为对象的实例化</li>
</ul>
<h3 id="构造函数的成员"><a href="#构造函数的成员" class="headerlink" title="构造函数的成员"></a>构造函数的成员</h3><p>构造函数中的属性和方法都称为成员，成员可以随意添加，成员分为实例成员和静态成员。实例成员就是构造函数内部通过 this 添加的成员，实例成员只能通过实例化的对象来访问。静态成员是在构造函数本身上添加的成员。静态成员只能通过构造函数来访问。</p>
<pre class="line-numbers language-none"><code class="language-none">function Studio(name) {
  this.name = name;
}
var puji = new Studio('PUJI');
console.log(puji.name); // 实例成员只能通过实例化的对象来访问，不可通过构造函数来访问，如 Star.name
Studio.age = 36;
console.log(Studio.age); // 静态成员只能通过构造函数来访问，不能通过实例化对象来访问
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="原型-Prototype"><a href="#原型-Prototype" class="headerlink" title="原型 Prototype"></a>原型 Prototype</h3><p>构造函数通过原型分配的函数，是所有对象所共享的。</p>
<p>JavaScript 规定，每一个构造函数都有一个原型属性，指向另一个对象，这个原型就是一个对象，对象的所有属性和方法都会被构造函数所拥有。我们可以把一些不变的方法，直接定义在原型对象上，这样所有对象的实例就可以共享这些方法。</p>
<p>一般情况下，我们公共属性定义到构造函数里，方法放在原型对象里。</p>
<p>实例化的对象系统会自动添加一个 <strong>proto</strong> 原型，指向了构造函数的原型对象 prototype， <strong>proto</strong> 和 prototype 是相同的空间。方法查找规则，先看对象身上是否有此方法，如果有就执行，没有就去原型对象身上去查找。</p>
<h3 id="添加-x2F-修改-x2F-删除属性"><a href="#添加-x2F-修改-x2F-删除属性" class="headerlink" title="添加/修改/删除属性"></a>添加/修改/删除属性</h3><p>使用 “对象名+属性名” 的方式进行添加或修改属性，也可使用 Object.defineProperty()</p>
<pre class="line-numbers language-none"><code class="language-none">// 添加属性
var obj = {
  uname: 'PUJI',
  age: 36
}
obj.sex = 'male';

// 修改属性
var obj = {
  uname: 'PUJI',
  age: 36,
  sex: 'male'
}
obj.uname = 'Wewe';

// 删除属性
var obj = {
  uname: 'PUJI',
  age: 36,
  sex: 'male'
}
delete obj.sex;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h3><p>调用对象的属性有两种方法，第一种方法采取 “对象名.属性名” 的形式，第二种方法 “对象名[‘属性名’]”，调用对象的方法采用 “对象名.方法名()”</p>
<pre class="line-numbers language-none"><code class="language-none">// 调用属性方法1
obj.age;

// 调用属性方法2
obj['age'];

// 调用方法的方法
obj.sayHi();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>变量、属性、函数、方法的区别</p>
<p>变量和属性都是用于存储数据的，变量单独声明并赋值，使用的时候直接写变量名，属性是在对象里，不需要声明，使用的时候必须是对象.属性名</p>
<p>函数和方法都是实现某种功能或做某件事，函数是单独声明并且调用的，方法在对象里，无需声明，调用的时候需 对象.方法()</p>
<h3 id="简化对象写法-ES6"><a href="#简化对象写法-ES6" class="headerlink" title="简化对象写法 (ES6)"></a>简化对象写法 (ES6)</h3><p>允许在花括号里，直接写入变量和函数，作为对象的属性和方法。</p>
<pre class="line-numbers language-none"><code class="language-none">// 之前的写法
var name = 'PUJI';
var work = function() {
  console.log(name)
}
var obj = {
  name: name,
  work: work,
  change: function() {
    console.log('Design Studio');
  }
}

// ES6 简化写法
let name = 'PUJI';
let work = function() {
  console.log(name)
}
const obj = {
  name,
  work, // 属性名和变量名一致时赋值的简化
  change() {
    console.log('Design Studio'); // 声明方法的简化
  }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="遍历对象-for-…-in"><a href="#遍历对象-for-…-in" class="headerlink" title="遍历对象 for … in"></a>遍历对象 for … in</h3><p>for … in 语句用于对数组或对象的属性进行循环操作</p>
<pre class="line-numbers language-none"><code class="language-none">for (变量 in 对象);

// 示例
var obj = {
  uname: 'Wewe',
  age: 36,
  sex: 'male',
  sayHi: function() {
    ...
  }
}
for (var k in obj) {
  console.log(k); //得到的是属性名
  console.log(obj[k]);// 得到的是属性值
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用 for in 语句时，变量名常常使用 k 或者 key</p>
<h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>用于获取对象自身所有的属性，效果类似 for … in。返回一个由属性名组成的新数组。</p>
<pre class="line-numbers language-none"><code class="language-none">var obj = {
  name: 'PUJI',
  age: 36
}
var arr = Object.keys(obj);
console.log(arr); // ['name', 'age']
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><p>视频教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17y4y1J7L1?p=49">https://www.bilibili.com/video/BV17y4y1J7L1?p=49</a></p>
<p>定义对象中新属性或修改原有的属性。</p>
<pre class="line-numbers language-none"><code class="language-none">Object.defineProperty(obj, prop, descriptor);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>obj: 目标对象</li>
<li>prop: 需定义或修改的属性名称</li>
<li>descriptor: 目标属性所拥有的特性。<ul>
<li>value ( 设置属性值，默认为 undefined )</li>
<li>writeable ( 值是否可重写，true / false 默认为 false )</li>
<li>enumerable ( 目标属性是否可以被枚举（遍历），true / false 默认为 false )</li>
<li>configurable ( 目标属性是否可以被删除或再次修改 descriptor 里的特性，true / false 默认为 false )</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">var obj = {
  uname: 'PUJI',
  age: 36
}
Object.defineProperty(obj, 'sex', {
  value: 'male'
});
console.log(obj);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>使用此函数，如果以前的对象中有新增的这个属性名则进行修改，如果没有则添加</li>
</ul>
<h2 id="面向对象-ES6"><a href="#面向对象-ES6" class="headerlink" title="面向对象 (ES6)"></a>面向对象 (ES6)</h2><ul>
<li>能够说出什么事面向对象</li>
<li>能够说出类和对象的关系</li>
<li>能够使用 class 创建自定义类</li>
<li>能够说出什么是继承</li>
</ul>
<h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><h5 id="编程的两大思想："><a href="#编程的两大思想：" class="headerlink" title="编程的两大思想："></a>编程的两大思想：</h5><ul>
<li>面向过程 POP：Process-oriented programming，就是分析出解决问题所需要的步骤，然后再用函数把这些步骤一步步实现，使用的时候再一个一个的依次调用即可；</li>
<li>面向对象 OOP：Object Oriented Programming，就是把事物分解成一个个对象，然后由对象之间分工与合作。面向对象就是以对象功能来划分问题，而不是步骤。面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作或复杂的大型软件项目。</li>
</ul>
<h5 id="面向过程与面向对象的对比"><a href="#面向过程与面向对象的对比" class="headerlink" title="面向过程与面向对象的对比"></a>面向过程与面向对象的对比</h5><ul>
<li>面向过程性能比面向对象高，适合跟硬件联系很紧密的东西，但没有面向对象易维护、易复用、易扩展。</li>
</ul>
<h5 id="面向对象的特性："><a href="#面向对象的特性：" class="headerlink" title="面向对象的特性："></a>面向对象的特性：</h5><ul>
<li>封装性</li>
<li>继承性</li>
<li>多态性</li>
</ul>
<h5 id="面向对象的思维特点"><a href="#面向对象的思维特点" class="headerlink" title="面向对象的思维特点"></a>面向对象的思维特点</h5><p>面向对象更贴近我们的实际生活，可以使用面向对象描述现实世界的事物，但是事物分为抽象的事物和具体的事物</p>
<ul>
<li>抽取对象共同的属性和行为封装成一个类（模版）；</li>
<li>对类进行实例化，获取类的对象。</li>
</ul>
<p>在 javascript 中，对象是一组无须的相关属性和方法的集合，所有的事物都是对象，如字符串、数值、数组、函数等。对象由属性和方法组成。</p>
<h3 id="类-class"><a href="#类-class" class="headerlink" title="类 class"></a>类 class</h3><p>在 ES6 中新增加了类的概念，可以使用 class 关键词声明一个类，之后以这个类来实例化对象。类抽象了对象的公共部分，泛指某一大类，对象特指通过实例化出的一个具体对象</p>
<h4 id="书写语法"><a href="#书写语法" class="headerlink" title="书写语法"></a>书写语法</h4><pre class="line-numbers language-none"><code class="language-none">class Name {
  ...
}
var a = new Name()；
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="类-constructor-构造函数"><a href="#类-constructor-构造函数" class="headerlink" title="类 constructor 构造函数"></a>类 constructor 构造函数</h3><p>constructor() 方法是类的构造函数（默认方法），用于传递参数，返回实例对象，<strong>通过 new 命令生成对象实例时，自动调用该方法</strong>，如果没有定义，类内部会自动给我们创建一个 constructor()</p>
<p>对象原型 ( <strong>proto</strong> ) 和构造函数原型对象 ( prototype )里都有一个构造函数 constructor，因为他指回构造函数本身，constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。</p>
<pre class="line-numbers language-none"><code class="language-none">class Star {
  constructor(uname, age) {
    this.uname = uname;
    this.age = age;
  }
}
var ldh = new Star('刘德华',18);
var zxy = new Star('张学友',19);
console.log(ldh);
console.log(zxy);
console.log(Star.prototype.constructor); //返回原来的构造函数
console.log(ldh.__proto__.constructor);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>通过 class 关键字创建类，类名首字母大写；</li>
<li>类里有个 constructor 函数，可以接受传递过来的参数，同时返回实例对象；</li>
<li>constructor 函数只要 new 生成实例时，就会自动调用这个函数，如果不写这个函数，类也会自动生成；</li>
<li>生成实例 new 不能省略；</li>
<li>创建类类名后面不要小括号，生成实例类名后面加小括号，构造函数不需要加 function</li>
</ul>
<h3 id="类中添加方法"><a href="#类中添加方法" class="headerlink" title="类中添加方法"></a>类中添加方法</h3><pre class="line-numbers language-none"><code class="language-none">window.addEventListener('load', function() {
    class Star {
        constructor(uname, age) {
            this.uname = uname;
            this.age = age;
        }
        sing(song) {
            console.log(this.uname + song);
        }
    }
    var ldh = new Star('刘德华',18);
    var zxy = new Star('张学友',19);
    ldh.sing('冰雨');
    zxy.sing('李香兰');
});
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>类里的所有函数不需要写 function；</li>
<li>多个函数方法之间不需要添加逗号分隔；</li>
</ul>
<h3 id="extends-类的继承"><a href="#extends-类的继承" class="headerlink" title="extends 类的继承"></a>extends 类的继承</h3><p>可以继承父类的属性与方法</p>
<pre class="line-numbers language-none"><code class="language-none">class A {
  constructor() {
    this.name = 'PUJI';
  }
}
class B extends A {}
var son = new B();
console.log(son);  // {name: PUJI}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就先执行子类</li>
<li>如果子类没有，就去查找父类有没有这个方法，如果有就执行（就近原则）</li>
</ul>
<h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h3><p>super 关键字用于访问和调用对象父类上的函数，可以调用父类的构造函数，也可以调用父类的普通函数。</p>
<pre class="line-numbers language-none"><code class="language-none">// 调用父类的构造函数
class A {
  constructor(x,y) {
    this.x = x;
    this.y = y;
  }
  sum() {
    console.log(this.x + this.y);
  }
}
class B extends A {
  constructor(x,y) {
    super(x,y); // 调用了父类中的构造函数
  }
}
var son = new B(1,2);
son.sum();

// 调用父类的普通函数
class A {
  say() {
    return 'PUJI Design';
  }
}
class B extends A {
  say() {
    console.log( super.say() + ' * Digital * Branding * Coding');
  }
}
var son = new B();
son.say();

// 子类可以继承父类的方法也可以扩展自己的方法
class A {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  sum() {
    console.log(this.x + this.y);
  }
}
class B extends A {
  constructor(x, y) {
    super(x,y);
    this.x = x;
    this.y = y;
  }
  substract() {
    console.log(this.x - this.y);
  }
}
var son = new B(6,3);
son.sum();
son.substract();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>当子类有自己的 this 时，super 必须在子类 this 之前调用</li>
</ul>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ol>
<li>在 ES6 中，类没有进行变量提升，所以必须先定义类，才能通过 new 实例化对象</li>
<li>类里有公用的属性和方法，一定要加 this 使用</li>
<li>constructor 里的 this 指向的是创建的实例对象</li>
</ol>
<h2 id="正则表达式-Regular-Expression"><a href="#正则表达式-Regular-Expression" class="headerlink" title="正则表达式 (Regular Expression)"></a>正则表达式 (Regular Expression)</h2><p>视频教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17y4y1J7L1?p=76">https://www.bilibili.com/video/BV17y4y1J7L1?p=76</a></p>
<p>正则表达式在线测试工具：<a target="_blank" rel="noopener" href="https://c.runoob.com/front-end/854">https://c.runoob.com/front-end/854</a></p>
<p>目标：</p>
<ul>
<li>能够说出正则表达式的作用；</li>
<li>能够写出简单的正则表达式；</li>
<li>能够使用正则表达式对表单进行验证；</li>
<li>能够使用正则表达式替换内容。</li>
</ul>
<p>正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象。</p>
<h3 id="正则表达式的用途"><a href="#正则表达式的用途" class="headerlink" title="正则表达式的用途"></a>正则表达式的用途</h3><p>正则表达式通常被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名表单只能输入英文字母、数字或者下划线，昵称输入框中可以输入中文<strong>（匹配）</strong>。此外，正则表达式还常用于过滤掉页面内容中的一些敏感词<strong>（替换）</strong>，或从字符串中获取我们想要的特定部分<strong>（提取）</strong>等。</p>
<ul>
<li>正则表达式具有灵活性、逻辑性和功能性非常强；</li>
<li>可以迅速地用极简单的方式达到字符串的复杂控制；</li>
<li>在实际开发，一般都是直接复制写好的正则表达式，但是要求会使用正则表达式并且根据实际情况修改正则表达式。</li>
</ul>
<h3 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h3><p>在 JavaScript 中，可以通过两种方式创建正则表达式。</p>
<pre class="line-numbers language-none"><code class="language-none">// 通过调用 RegExp 对象的构造函数创建
var 变量名 = new RegExp(/表达式/);
var regexp = new RegExp(/123/);

// 通过字面量创建 (更常用)
var 变量名 = /表达式/;
var regexp = /123/;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>正则表达式里的内容不需要加引号，不管是数字型还是字符串型</li>
</ul>
<h3 id="测试正则表达式"><a href="#测试正则表达式" class="headerlink" title="测试正则表达式"></a>测试正则表达式</h3><p>test() 正则表达式对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false，其参数是测试字符串。</p>
<pre class="line-numbers language-none"><code class="language-none">regexObj.test(str);

// 示例
var rg = /abc/;
console.log(rg.test('abc')); // true
console.log(rg.test('abcd')); // true
console.log(rg.test('aabcd')); // true
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>regexObj 是写的正则表达式</li>
<li>str 需要测试的文本</li>
<li>test 中的字符串需要引号</li>
<li>文字中只要其中一部分匹配表达式里的文字，就返回 true</li>
</ul>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>一个正则表达式可以由简单的字符构成，比如 /abc/，也可以是简单和特殊字符的组合，如 /ab*c/。其中特殊字符也被称为元字符，在正则表达式中是最具特殊意义的专用字符。</p>
<p>更多字符参考链接<br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions</a></p>
<h5 id="边界符"><a href="#边界符" class="headerlink" title="边界符"></a>边界符</h5><table>
<thead>
<tr>
<th>边界符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>表示匹配行首的文本（以谁开始）</td>
</tr>
<tr>
<td>$</td>
<td>表示匹配行尾的文本（以谁结束）</td>
</tr>
</tbody></table>
<pre class="line-numbers language-none"><code class="language-none">// 以 abc 开头的字符
var rg = /^abc/;
console.log(rg.test('abc')); // true
console.log(rg.test('abcd')); // true
console.log(rg.test('aabcd')); // false

// 以 abc 结尾的字符
var rg = /abc$/;
console.log(rg.test('abc')); // true
console.log(rg.test('abcaaabc')); // true
console.log(rg.test('aabcd')); // false

// 精确匹配，必须是 abc 字符串
var rg = /^abc$/;
console.log(rg.test('abc')); // true
console.log(rg.test('abcabc')); // false
console.log(rg.test('aabcd')); // false
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h5><p>使用 [] 表示有一系列字符可供选择，只要匹配其中一个就可以</p>
<pre class="line-numbers language-none"><code class="language-none">// 只要包含有 a 或者有 b 或者有 c 都返回 true
var rg = /[abc]/;
console.log(rg.test('ikaie')); // true
console.log(rg.test('bcoej')); // true
console.log(rg.test('eiowloo')); // false

// 只有是 a / b / c 这三个字母才返回 true
var rg = /^[abc]$/;
console.log(rg.test('a')); // true
console.log(rg.test('b')); // true
console.log(rg.test('d')); // false

// 只要是单个英文小写字母都返回 true '-' 表示一个范围
var rg = /^[a-z]$/;
console.log(rg.test('a')); // true
console.log(rg.test('f')); // true
console.log(rg.test('B')); // false

// 只要是单个英文字母(含大小写)或数字或_或-都返回 true
var rg = /^[a-zA-Z0-9_-]$/;
console.log(rg.test('a')); // true
console.log(rg.test('D')); // true
console.log(rg.test('code')); // false
console.log(rg.test('6')); // true

// 中括号内有^ 表示取反，不能包含里面的内容
var rg = /^[^a-zA-Z0-9_-]$/;
console.log(rg.test('a')); // false
console.log(rg.test('D')); // false
console.log(rg.test('code')); // false
console.log(rg.test('*')); // true
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="量词符"><a href="#量词符" class="headerlink" title="量词符"></a>量词符</h5><p>用于设定某个模式出现的次数</p>
<table>
<thead>
<tr>
<th>量词</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td>?</td>
<td>重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复 n 次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复 n 次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复 n 到 m 次</td>
</tr>
</tbody></table>
<pre class="line-numbers language-none"><code class="language-none">// 重复0次或以上
var rg = /^a*$/;
console.log(rg.test('')); // true
console.log(rg.test('aaa')); // true
console.log(rg.test('aaabaaa')); // false
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="括号的使用"><a href="#括号的使用" class="headerlink" title="括号的使用"></a>括号的使用</h3><p>方括号 [] 表示字符集合，匹配方括号中的任意字符</p>
<pre class="line-numbers language-none"><code class="language-none">var rg = /[abc]/; // 只要包含有 a / b / c 任意一个
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>花括号 {} 为量词符，表示重复次数</p>
<pre class="line-numbers language-none"><code class="language-none">rg = /^abc{3}$/; // 只是让花括号前面一个字符重复三次 abccc
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>圆括号 () 表示优先级</p>
<pre class="line-numbers language-none"><code class="language-none">rg = /^(abc){3}$/; // 让 abc 重复三次 abcabcabc
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>| 表示或</p>
<h3 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h3><p>预定义类指某些常见的模式的简写形式</p>
<table>
<thead>
<tr>
<th>预定义类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\d</td>
<td>匹配 0-9 之间的任一数字，相当于[0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>匹配所有 0-9 以外的字符，相当于[^0-9]</td>
</tr>
<tr>
<td>\w</td>
<td>匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]</td>
</tr>
<tr>
<td>\W</td>
<td>除所有字母、数字和下划线以外的字符，相当于[^a-za-z0-9_]</td>
</tr>
<tr>
<td>\s</td>
<td>匹配空格(包含换行符、制表符、空格符等)，相当于[\t\r\n\v\f]</td>
</tr>
<tr>
<td>\S</td>
<td>匹配非空格的字符，相当于[^\t\r\n\v\f]</td>
</tr>
</tbody></table>
<h3 id="正则表达式参数"><a href="#正则表达式参数" class="headerlink" title="正则表达式参数"></a>正则表达式参数</h3><pre class="line-numbers language-none"><code class="language-none">/表达式/[switch];

/激情|刺激/g
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>switch 也称为修饰符，按照什么样的模式来匹配，有三种值</p>
<ul>
<li>g: 全局匹配，表示可获取整段文字中所有符合的内容。</li>
<li>i: 忽略大小写</li>
<li>gi: 全局匹配 + 忽略大小写</li>
</ul>
<h3 id="replace-替换"><a href="#replace-替换" class="headerlink" title="replace() 替换"></a>replace() 替换</h3><p>replace() 方法可以实现替换字符串操作，用来替换的参数可以是一个字符或事一个正则表达式</p>
<pre class="line-numbers language-none"><code class="language-none">stringObject.replace(regexp/substr, replacement)

// 替换字符串
var str = 'PUJI Design';
var newStr = str.replace('Design', 'Lab');
console.log(newStr); // PUJI Lab

// 正则表达式
// 替换字符串
var str = 'PUJI Design';
var newStr = str.replace(/Design/gi, 'Lab');
console.log(newStr); // PUJI Lab
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p>目标</p>
<ul>
<li>能够说出什么是内置对象</li>
<li>能够根据文档查询指定 API 的使用方法</li>
<li>能够使用 Math 对象的常用方法</li>
<li>能够使用 Date 对象的常用方法</li>
<li>能够使用 Array 对象的常用方法</li>
<li>能够使用 String 对象的常用方法</li>
</ul>
<h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>内置对象就是 JavaScript 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能（属性和方法）。常用的内置对象包含 Math, Date, Array, String 等</p>
<p>查阅文档</p>
<p>可以通过 MDN / W3C 来查询，Mozilla 开发者网络（MDN） 提供了有关开放网络技术 （Open Web）的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></p>
<h3 id="Math-数学对象"><a href="#Math-数学对象" class="headerlink" title="Math 数学对象"></a>Math 数学对象</h3><p>Math 是一个内置对象，它拥有一些数学常数属性和数学函数方法。Math 不是一个函数对象。</p>
<p>封装自己的数学对象</p>
<pre class="line-numbers language-none"><code class="language-none">var myMath = {
    PI: 3.1415926,
    max: function() {
        var max = arguments[0];
        for (i = 1; i &lt; arguments.length; i++) {
            if (arguments[i] &gt; max) {
                max = arguments[i];
            }
        }
        return max;
    },
    min: function() {
        var min = arguments[0];
        for (i = 1; i &lt; arguments.length; i++) {
            if (arguments[i] &lt; min) {
                min = arguments[i];
            }
        }
        return min;
    }
}
console.log(myMath.PI);
console.log(myMath.max(1, 6, 9, 36, -15));
console.log(myMath.min(1, 6, 9, 36, -15));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="日期对象"><a href="#日期对象" class="headerlink" title="日期对象"></a>日期对象</h3><p>是一个构造函数，使用 new 来调用创建我们的日期对象</p>
<pre class="line-numbers language-none"><code class="language-none">var date = new Date();
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>使用 Date 如果没有参数，返回当前系统的当前时间</li>
<li>参数常用写法，数字型 2022, 03, 03 或者是字符串型 ‘2022-03-03 12:36:18’</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">var date = new Date('2022-03-03 12:36:18');
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="扩展内置对象"><a href="#扩展内置对象" class="headerlink" title="扩展内置对象"></a>扩展内置对象</h4><p>视频教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17y4y1J7L1?p=33&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV17y4y1J7L1?p=33&amp;spm_id_from=pageDriver</a></p>
<p>可以通过原型对象，对原来的内置对象进行扩展自定义的方法，比如给数组增加自定义求偶数和的功能。</p>
<h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><p>在 JavaScript 上提供了三个特殊的引用类型，分别是 String / Number / Boolean。把简单数据类型包装为复杂数据类型就是基本包装类型，这样基本数据类型就有了属性和方法。</p>
<pre class="line-numbers language-none"><code class="language-none">// 示例
var str = 'PUJI';
console.log(str.length);

// js的处理过程
var temp = new String('PUJI'); // 新建一个对象
str = temp; // 把临时变量的值赋予 str
temp = null; //销毁临时变量
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="预解析（重要）"><a href="#预解析（重要）" class="headerlink" title="预解析（重要）"></a>预解析（重要）</h2><p>目标</p>
<ul>
<li>能够知道解析器运行 js 分为哪两步</li>
<li>能够说出变量提升的步骤和运行过程</li>
<li>能够说出函数提升的步走和运行过程</li>
</ul>
<h3 id="什么是预解析"><a href="#什么是预解析" class="headerlink" title="什么是预解析"></a>什么是预解析</h3><pre class="line-numbers language-none"><code class="language-none">// 示例1
console.log(num); // undefined
var num = 10;

// 示例2 (成功调用)
fn();
function fn() {
  console.log(1);
}

// 示例3 (报错)
fn();
var fun = function() {
  console.log(1);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两步：预解析和代码执行。</p>
<ol>
<li>预解析：JavaScript 引擎会把 js 里所有的 var 还有 function 提升到当前作用域的最前面</li>
<li>预解析分为变量预解析（变量提升）和函数预解析（函数提升）</li>
<li>变量提升，就是把所有的变量声明提升到当前的作用与前面，不提升赋值。</li>
<li>函数提升，就是把所有的函数声明与函数体提升到当前作用域的前面，但不做调用。</li>
<li>代码执行：按照代码书写的顺序从上往下执行</li>
</ol>
<p>按照预解析的过程来分析，我们可以把上面的代码的流程按照解析过程来进行顺序分析，相当于代码按照以下顺序进行执行</p>
<pre class="line-numbers language-none"><code class="language-none">// 示例1 (由于在执行语句前只声明了变量，但没赋值)
var num;
console.log(num); // undefined
num = 10;

// 示例2 (成功调用)
function fn() {
  console.log(1);
}
fn();

// 示例3 (报错)
var fun； (由于在调用语句前只声明了变量，但没赋值，fn属于变量而非函数)
fn();
fun = function() {
  console.log(1);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="严格模式-Strict-mode"><a href="#严格模式-Strict-mode" class="headerlink" title="严格模式 (Strict mode)"></a>严格模式 (Strict mode)</h2><p>JavaScript 除了提供正常模式外，还提供了严格模式。ES5 的严格模式是采用具有限制性 JavaScript 变体的一种方式，即在严格的条件下运行 JS 代码。</p>
<ul>
<li>严格模式对正常的 JavaScript 语法的一些不合理、不严谨之处，减少了一些怪异行为；</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>
<li>提高编译效率，增加运行速度；</li>
<li>禁用了在 ECMAScript 的未来版本中可能会定义的一些语法不可用于变量名。</li>
</ul>
<h3 id="开启严格模式"><a href="#开启严格模式" class="headerlink" title="开启严格模式"></a>开启严格模式</h3><p>视频教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17y4y1J7L1?p=59">https://www.bilibili.com/video/BV17y4y1J7L1?p=59</a><br>更多规则参考链接：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode</a></p>
<p>严格模式可以应用到整个脚本或个别函数中，因此在使用时，我们可以将严格模式分为<strong>为脚本开启严格模式</strong>和<strong>为函数开启严格模式</strong>两种情况。</p>
<h4 id="为脚本开启严格模式"><a href="#为脚本开启严格模式" class="headerlink" title="为脚本开启严格模式"></a>为脚本开启严格模式</h4><p>为整个脚本文件开启严格模式，只需在所有语句之前放一个特定语句 “use strict” 或 ‘use strict’。</p>
<pre class="line-numbers language-none"><code class="language-none">// 开启严格模式
'use strict';
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="为函数开启严格模式"><a href="#为函数开启严格模式" class="headerlink" title="为函数开启严格模式"></a>为函数开启严格模式</h4><pre class="line-numbers language-none"><code class="language-none">function fn() {
  'use strict';
  ...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="变量规定"><a href="#变量规定" class="headerlink" title="变量规定"></a>变量规定</h3><ul>
<li>变量必须先声明然后再使用；</li>
<li>严禁删除已经声明过的变量。</li>
</ul>
<h3 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h3><ul>
<li>全局作用域中定义的函数的 this 是 undefined 而不再是 window；</li>
<li>构造函数如果不加 new 进行调用，this 会报错，new 实例化的构造函数指向创建的对象实例；</li>
<li>定时器的 this 还是指向 window；</li>
<li>事件、对象里的 this 还是指向调用者。</li>
</ul>
<h3 id="函数变化"><a href="#函数变化" class="headerlink" title="函数变化"></a>函数变化</h3><ul>
<li>函数的形参名称不可重名；</li>
<li>函数声明必须在顶层，不允许在非函数的代码块内声明函数 (如括号内，if，for 等)。</li>
</ul>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">谢亦凯</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://155strive.github.io/2022/12/23/javascript-ji-chu-zhi-shi/">https://155strive.github.io/2022/12/23/javascript-ji-chu-zhi-shi/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">谢亦凯</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/javascript/">
                                    <span class="chip bg-color">javascript</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力,爱你！</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    
    <div class="livere-card card" data-aos="fade-up">
    <!-- 来必力City版安装代码 -->
    <div id="lv-container" class="card-content" data-id="city" data-uid="MTAyMC81NjYyNi8zMzA4OQ==">
        <script type="text/javascript">
            (function (d, s) {
                let j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') {
                    return;
                }

                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript。</noscript>
    </div>
    <!-- City版安装代码已完成 -->
</div>
    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'McoPcX5rz8BeF036PI4mWbqX-gzGzoHsz',
        appKey: 'pKjSikkayUmj4nzx5IcyEeWK',
        serverURLs: '',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '宝贝儿，说两句'
    });
</script>

<!--酷Q推送-->


    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/12/23/jquery/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/19.jpg" class="responsive-img" alt="jquery基础知识">
                        
                        <span class="card-title">jquery基础知识</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-12-23
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            谢亦凯
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/jquery/">
                        <span class="chip bg-color">jquery</span>
                    </a>
                    
                    <a href="/tags/%E5%BA%93/">
                        <span class="chip bg-color">库</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/12/23/fang-dou-he-jie-liu/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="防抖和节流">
                        
                        <span class="card-title">防抖和节流</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-12-23
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            谢亦凯
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E9%9D%A2%E8%AF%95/">
                        <span class="chip bg-color">面试</span>
                    </a>
                    
                    <a href="/tags/javascript/">
                        <span class="chip bg-color">javascript</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="tencent"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2022</span>
            
            <a href="/about" target="_blank">谢亦凯</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">32.1k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2022";
                        var startMonth = "6";
                        var startDate = "16";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1554388845@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1554388845" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1554388845" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/snow.js"><\/script>');
            }
        </script>
    

    <!-- 鼠标星星特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/star.js"><\/script>');
            }
        </script>
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
